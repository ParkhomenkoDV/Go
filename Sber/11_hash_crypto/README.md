# Введение в спринт 4

Приветствуем вас в четвёртом спринте нашего курса по языку Go!

## Что вас ждёт?

В этом спринте вы:
- научитесь хэшировать, подписывать и шифровать ценную информацию;
- узнаете, как авторизовывать пользователей с помощью JSON Web Tokens;
- изучите основы многопоточности в операционных системах;
- подробно разберете многопоточность в Go и встроенные примитивы синхронизации: мьютексы, каналы и атомики;
- рассмотрите различные паттерны многопоточной обработки данных.

## Проектные инкременты

- В рамках спринта вы продолжите развивать свой проект и реализуете следующие новые возможности:
добавите аутентификацию пользователей;
- реализуете многопоточную обработку большого объёма данных.

## Покрытие кода тестами

**Внимание:** к концу спринта рекомендуется покрыть код тестами на **30%**.
Напоминаем, что во второй части курса требование к покрытию станет обязательным.

## Карта курса

![](./assets/images/Part1-all-sprint4.png)

Новый спринт — новые вершины!

# Хеширование и шифрование

В цифровом мире данные — наиболее важный и одновременно наиболее уязвимый элемент системы. Хакеры изобретают новые способы взлома сайтов и приложений. Целью атак могут быть личные данные пользователей или программный код. Столкнуться с утечкой — значит потерять доверие аудитории. Мало кто захочет пользоваться сервисом, разработчики которого не заботятся о защите конфиденциальной информации.

Сервис, который вы написали, выполняя инкременты, уже достаточно большой и сложный. Вы подключили базу данных и организовали обмен информацией между сервером и клиентом. Пришло время сделать ваш сервис безопаснее.

В этой теме вы научитесь: 
- работать с криптостойким генератором случайных чисел (он применяется для создания ключей и паролей);
- вычислять хеши SHA-256 и MD5 (хеши используются для контроля целостности и подписывания данных);
- подписывать данные (подпись нужна для генерации токенов);
- зашифровывать и расшифровывать данные алгоритмом симметричного шифрования AES;
- защищать данные и пароли.

![](./assets/images/crypto.png)

Наука о методах защиты информации путём использования алгоритмов шифрования, хеширования и подписывания называется криптографией (cryptography). Цель — обеспечить безопасность данных, а именно:
- конфиденциальность (невозможность для посторонних прочесть информацию);
- целостность (невозможность незаметно изменить информацию);
- аутентификацию (возможность проверить и подтвердить подлинность авторства и других свойств объекта).

**Шифрование** (encryption), или **алгоритм шифрования**, — это технология кодирования и декодирования данных. Цель шифрования — сделать данные недоступными для чтения постороннему наблюдателю, даже если их удалось перехватить. Современные алгоритмы шифрования используют сложные математические вычисления и один или несколько ключей шифрования. Благодаря этому можно зашифровать сообщение, но практически невозможно его расшифровать, не зная ключей.

При кодировании данных взаимодействуют **отправитель** и **получатель**. Отправитель шифрует и подписывает сообщения, а получатель — расшифровывает и проверяет подписи.

Алгоритмы шифрования бывают **симметричные** и **асимметричные**. В симметричных алгоритмах отправитель и получатель используют один и тот же ключ.

![](./assets/images/sprint2_picture1.png)

С помощью симметричного ключа алгоритм преобразует сообщение из обычного текста в зашифрованный.

![](./assets/images/sprint2_picture2.png)

Алгоритм преобразует зашифрованный текст в обычный с помощью того же симметричного ключа.

В асимметричных алгоритмах для шифрования данных используются приватные и публичные ключи. Например, пользователь в чате отправляет вам данные, зашифрованные вашим публичным ключом, но расшифровать их сможете только вы — своим приватным ключом. Также вы можете подписать файл или сообщение приватным ключом, а другой человек — проверить его подлинность, зная публичный ключ.

**Открытый** (публичный) ключ доступен всем. Он используется для шифрования данных. **Закрытый** (приватный) ключ известен только владельцу. Используется для расшифровки данных.

Применение асимметричных алгоритмов значительно упрощает обмен ключами, так как публичные ключи могут передаваться по открытым каналам связи. Тема асимметричных алгоритмов очень объёмная, поэтому не включена в этот курс. Рассмотрим подробно только симметричные ключи.

*Существует несколько способов защиты данных. Самый простой — использовать генератор случайных чисел для создания шифров, одноразовых паролей, ключей и цифровых подписей.
Одноразовые пароли, которые приходят в смс при покупках в интернете, создаются таким генератором.*

## Генераторы случайных чисел

**Генератор псевдослучайных чисел** — это генератор, который производит случайные байты на основе стартового числа seed и математического алгоритма. Зная число seed, можно повторить дальнейшую последовательность байт.
Чтобы написать программу для генерации случайных чисел на Go, можно использовать пакет [math/rand](https://pkg.go.dev/math/rand) стандартной библиотеки. Рассмотрим, как работают псевдослучайные числа, которые предлагает этот пакет. Напишем простую программу:
```go
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    // NewSource возвращает новый псевдослучайный источник с заданным значением.
    sec1 := rand.New(rand.NewSource(10))
    sec2 := rand.New(rand.NewSource(10))

    for i := 0; i < 5; i++ {
        // генерация случайных значений из источников
        rnd1 := sec1.Int()
        rnd2 := sec2.Int()
        if rnd1 != rnd2 {
            fmt.Println("Сгенерированная случайным образом последовательность")
            break
        } else {
            fmt.Printf("rnd1: %d, rnd2: %d\n", rnd1, rnd2)
        }
    }
}
```

После запуска программы получим примерно такой вывод (у вас он может быть другим — это же рандом):
```bash
$ go run main.go
rnd1: 5221277731205826435, rnd2: 5221277731205826435
rnd1: 3852159813000522384, rnd2: 3852159813000522384
rnd1: 8532807521486154107, rnd2: 8532807521486154107
rmd1: 3888302351045490779, rnd2: 3888302351045490779
rmd1: 4512466281294657143, rnd2: 4512466281294657143
```

Обратите внимание, что значения повторяются. Этот вариант генерации псевдослучайных чисел **криптографически ненадёжен**. И вот почему. Он позволяет генерировать одинаковую последовательность с одинаковым номером seed, используя метод `Source()`. Такой подход обычно применяется в тестах, так как он воспроизводит последовательность чисел.

Пакет `math/rand` не подходит для генерации чувствительных данных, например куки-файлов, токенов или ключей. Для подобных задач генератор случайных чисел должен сохранять **непредсказуемость** и быть стойким к дешифрованию.

- А можно как-то проверить, насколько надёжен генератор случайных чисел?
- Да, конечно. Для этого существует [тест на следующий бит](https://ru.wikipedia.org/wiki/Тест_на_следующий_бит).
- Что он проверяет?
- Криптостойкость. Тест должен предсказать следующий бит в последовательности случайных чисел, учитывая, что предыдущие биты уже известны. Если генератор случайных чисел будет стойким к дешифровке, то предсказать следующий бит, а значит, заполучить секретные данные практически невозможно.
- Даже если злоумышленник знает предыдущие биты?
- Верно. Можно сказать, что это «тест на случайность».

## Криптостойкий генератор случайных чисел

Выделяют два основных способа атак: 
- Первый — вычислить алгоритм генератора и математически вывести число seed на основе N чисел из последовательности.
- Второй — перебрать все последовательности под различными стартовыми числами seed. Так как в приложениях в качестве seed обычно используется текущее время, злоумышленникам гораздо легче подобрать значения.

От подобных атак спасает **криптостойкий генератор случайных чисел**. Он производит байты на основе энтропии, порождаемой аппаратно. Такую случайность нельзя предугадать, поэтому невозможно вывести всю последовательность. Этот генератор реализован на уровне операционной системы.

*Энтропия, или информационная энтропия, — это мера неопределённости. Чем больше неопределённость, тем больше энтропия.*

В Go сгенерировать криптостойкие случайные байты можно функцией `rand.Read()` из пакета `crypto/rand`. В параметре функции нужно передать слайс байт ненулевой длины, который будет заполнен случайными байтами. Размер слайса не изменяется.

Чтобы использовать полученный слайс байт, например для куки-файлов, нужно дополнительно его закодировать. Это можно сделать функцией `hex.EncodeToString()` из пакета `encoding/hex`:
```go
package main

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
)

func main() {
    // определяем слайс байт нужной длины
    b := make([]byte, 16)
    _, err := rand.Read(b) // записываем байты в слайс b
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    fmt.Println(hex.EncodeToString(b))
}
```

Результат:
```
90332ded063d20e3e41812d1902ad18d
```

В отличие от простого генератора псевдослучайных чисел, этот код будет каждый раз при запуске выводить новую последовательность байт.

Функция `hex.EncodeToString()` возвращает строку в 16-теричном формате.

___
Напишите функцию, которая будет генерировать слайс случайных байт. Размер слайса передаётся параметром. 

Функция должна возвращать слайс в виде строки в кодировке `base64`. Используйте пакет [encoding/base64](https://pkg.go.dev/encoding/base64).

Решение:
```go
func RandBytes(n int) (string, error) {
    b := make([]byte, n)
    _, err := rand.Read(b)
    if err != nil {
        return ``, err
    }
    return base64.StdEncoding.EncodeToString(b), nil
}
```
___

## Хеширование

**Хеш-функция** — это функция, преобразующая произвольный массив данных в строку фиксированной длины. Строка состоит из букв и цифр и представляет собой набор байтов. Длина строки зависит не от объёма данных, которые хешируются, а от используемого алгоритма.

С работой хеш-функции можно встретиться при регистрации нового адреса электронной почты. Созданные пользователем логин и пароль пропускаются через определённую хеш-функцию — значение хеша записывается в базу данных. После регистрации, когда пользователь вводит логин и пароль для входа, они снова пропускаются через хеш-функцию. Значение хеша сравнивается с тем, которое было записано в базу данных. Если значения совпадают, пользователь успешно войдёт в систему.

Результат работы хеш-функции называют **хешем**. Например, строка «Yandex Practicum» после хеширования алгоритмом MD5 (Message Digest 5) выглядит так:
```
1b126d63a8122a2f7c34d9983a4301d0
```

А строка «I love Yandex Practicum» — так:
```
b9652aa716b126cf8a393aa6d848ee4b
```

Длина хеша осталась той же, несмотря на то что вторая строка была длиннее.

Одно из основных требований к хеш-функции — уникальность получаемого хеша и практически полное отсутствие **коллизий**. Коллизия — это совпадение результатов хеш-функции при разных входящих данных. Обработка разных наборов данных не должна выдавать одинаковое значение хеша.

Хеши бывают **криптографические** и **некриптографические**. Некриптографические хеш-функции возвращают слишком короткую последовательность байт. Например, CRC32 и CRC64 (Cyclic Redundancy Check) возвращают 32- и 64-битные целые числа, что соответствует четырём и восьми байтам. Из-за этого часто возникают коллизии.

Особенность криптографических хеш-функций в том, что получить из результата изначальные данные или коллизию вычислительно сложно.

Если коллизию получить легко, это проблема. Например, если вы используете для создания подписи слабую хеш-функцию (MD5, SHA-1), то изначальные данные можно подделать. И вам не удастся это обнаружить, ведь хеш совпадает.

![](./assets/images/hash.png)

## Криптографические хеш-функции

Разберём подробнее криптографические хеш-функции. В Go есть общий для всех хеш-функций интерфейс — `hash.Hash`.

Для примера вычислим хеш функции SHA-256 (Secure Hash Algorithm). Реализация этой функции представлена в пакете [crypto/sha256](https://pkg.go.dev/crypto/sha256).

```go
package main

import (
    "crypto/sha256"
    "fmt"
)

func main() {
    src := []byte("Здесь могло быть написано, чем Go лучше Rust. " +
        "Но после хеширования уже не прочитаешь.")

    // создаём новый hash.Hash, вычисляющий контрольную сумму SHA-256
    h := sha256.New()
    // передаём байты для хеширования
    h.Write(src)
    // вычисляем хеш
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```

Если у вас есть байтовый слайс, то посчитать хеш SHA-256 можно вызовом одной функции: `Sum256(data []byte)`. Она возвращает массив из 32 байт — это длина получаемого хеша.

Ещё одна популярная хеш-функция — MD5 из пакета [crypto/md5](https://pkg.go.dev/crypto/md5). Она работает очень быстро и возвращает хеш длиной 16 байт. Хотя MD5 не рекомендуют использовать из-за низкой криптостойкости, эту функцию всё ещё применяют для подсчёта контрольных сумм файлов и хеширования некритичной информации.

___
Допишите программу, которая считает хеш случайной последовательности в 512 байт при помощи алгоритма MD5. Используйте интерфейс `hash.Hash` и функцию `md5.Sum([]byte)`.

```go
package main

import (
    "bytes"
    "crypto/md5"
    "crypto/rand"
    "fmt"
)

func main() {
    var (
        data  []byte         // слайс случайных байт
        hash1 []byte         // хеш с использованием интерфейса hash.Hash
        hash2 [md5.Size]byte // хеш, возвращаемый функцией md5.Sum
    )
    // допишите код
    // 1) сгенерируйте data длиной 512 байт
    // 2) вычислите hash1 с использованием md5.New
    // 3) вычислите hash2 функцией md5.Sum

    // ...

    // hash2[:] приводит массив байт к слайсу
    if bytes.Equal(hash1, hash2[:]) {
        fmt.Println("Всё правильно! Хеши равны")
    } else {
        fmt.Println("Что-то пошло не так")
    }
}
```

Результат:
```
# command-line-arguments
./main.go:6:5: "crypto/rand" imported and not used
./main.go:12:9: declared and not used: data
```

Решение автора:
```go
package main

import (
    "bytes"
    "crypto/md5"
    "crypto/rand"
    "fmt"
)

func main() {
    var (
        data  []byte         // слайс случайных байт
        hash1 []byte         // хеш с использованием интерфейса hash.Hash
        hash2 [md5.Size]byte // хеш, возвращаемый функцией md5.Sum
    )
    
    data = make([]byte, 512)
    _, err := rand.Read(data)
    if err != nil {
        panic(err)
    }

    h := md5.New()
    h.Write(data)
    hash1 = h.Sum(nil)

    hash2 = md5.Sum(data)
    
    if bytes.Equal(hash1, hash2[:]) {
        fmt.Println("Всё правильно! Хеши равны")
    } else {
        fmt.Println("Что-то пошло не так")
    }
}
```
___

## Подпись данных

При обмене данными по сети получателю важно идентифицировать отправителя и быть уверенным, что после отправки в эти данные не вносились изменения. В бумажных документах такой проблемы нет, потому что содержание документа и рукописная подпись автора закреплены на бумаге, то есть связаны физическим носителем данных. В электронных документах эта связь отсутствует.

Чтобы можно было проверить целостность данных и подлинность автора, используется цифровая подпись. Для этого создаётся определённая последовательность байт. При больших объёмах данных лучше вычислять и подписывать их хеш.

Рассмотрим, как можно подписывать данные при обмене информацией по сети. Предположим, новым пользователям приложения сервер выдаёт токены и пишет их в куки. При повторном обращении юзера сервер читает куки и идентифицирует пользователя. Как защититься от генерации и использования токенов посторонними лицами? Одно из решений — подписывать и проверять токены секретным ключом, который хранится на сервере.

Создадим подпись данных с помощью алгоритма HMAC (Hash-based Message Authentication Code). В отличие от обычных хеш-функций, для функции `hmac.New(h func() hash.Hash, key []byte) hash.Hash` нужно указать используемую криптографическую хеш-функцию и ключ.

```go
package main

import (
    "crypto/hmac"
    "crypto/rand"
    "crypto/sha256"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    // генерируем случайную последовательность байт
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    // подписываемое сообщение
    src := []byte("Видишь гофера? Нет. И я нет. А он есть.")

    // создаём случайный ключ
    key, err := generateRandom(16)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // подписываем алгоритмом HMAC, используя SHA-256
    h := hmac.New(sha256.New, key)
    h.Write(src)
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```

Результат:
```
e6c718396daddf12baf3e4fcaaa9235f59e34ac07828cec5edda434c1d4f0e3a
```

В этом примере невозможно проверить исходную строку и полученную подпись, так как случайный ключ исчез после завершения программы. Чтобы проверить подлинность подписи, нужно произвести две операции:
1. Заново пересчитать подпись с тем же ключом.
1. Функцией `hmac.Equal` проверить, что подписи совпадают.

___
Представьте, что вы получили сообщение, представленное строкой байтов в 16-теричном формате, состоящее из идентификатора `uint32` и подписи. Проверьте подпись алгоритмом HMAC, используя хеш-функцию SHA-256 и секретный ключ. Выведите значение идентификатора.

```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/binary"
    "encoding/hex"
    "fmt"
)

var secretkey = []byte("secret key")

func main() {
    var (
        data []byte // декодированное сообщение с подписью
        id   uint32 // значение идентификатора
        err  error
        sign []byte // HMAC-подпись от идентификатора
    )

    msg := "048ff4ea240a9fdeac8f1422733e9f3b8b0291c969652225e25c5f0f9f8da654139c9e21"

    // допишите код
    // 1) декодируйте msg в data
    // 2) получите идентификатор из первых четырёх байт,
    //    используйте функцию binary.BigEndian.Uint32
    // 3) вычислите HMAC-подпись sign для этих четырёх байт

    // ...

    if hmac.Equal(sign, data[4:]) {
        fmt.Println("Подпись подлинная. ID:", id)
    } else {
        fmt.Println("Подпись неверна. Где-то ошибка")
    }
}
```

Программа должна вывести: `Подпись подлинная. ID: 76543210`.

Решение автора:
```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/binary"
    "encoding/hex"
    "fmt"
)

var secretkey = []byte("secret key")

func main() {
    var (
        data []byte // декодированное сообщение с подписью
        id   uint32 // значение идентификатора
        err  error
        sign []byte // HMAC-подпись от идентификатора
    )

    msg := "048ff4ea240a9fdeac8f1422733e9f3b8b0291c969652225e25c5f0f9f8da654139c9e21"

    data, err = hex.DecodeString(msg)
    if err != nil {
        panic(err)
    }
    id = binary.BigEndian.Uint32(data[:4])
    h := hmac.New(sha256.New, secretkey)
    h.Write(data[:4])
    sign = h.Sum(nil)
    
    if hmac.Equal(sign, data[4:]) {
        fmt.Println("Подпись подлинная. ID:", id)
    } else {
        fmt.Println("Подпись неверна. Где-то ошибка")
    }
}
```
___

## Шифрование

Как уже было сказано, алгоритмы шифрования делятся на симметричные и асимметричные. Симметричные требуют для шифрования и расшифровки один и тот же ключ, асимметричные работают с приватными и публичными ключами.

![](./assets/images/algorithms.png)

Рассмотрим подробнее симметричные алгоритмы. Базовый интерфейс симметричного шифрования — `cipher.Block` из пакета [crypto/cipher](https://pkg.go.dev/crypto/cipher).

Зашифруем и расшифруем текст с помощью алгоритма AES (Advanced Encryption Standard). Это блочный алгоритм, размер блока — 16 байт.

Для работы алгоритма нужно сгенерировать ключ из 16, 24 или 32 байт. В зависимости от размера ключа будет выбрано шифрование AES-128, AES-192 или AES-256. Чем длиннее ключ, тем более криптостойким получится шифр.

```go
package main

import (
    "crypto/aes"
    "crypto/rand"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    // генерируем криптостойкие случайные байты в b
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    src := []byte("Слепой банкир") // данные, которые хотим зашифровать
    fmt.Printf("original: %s\n", src)

    // константа aes.BlockSize определяет размер блока, она равна 16 байтам
    key, err := generateRandom(aes.BlockSize) // ключ шифрования
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // получаем cipher.Block
    aesblock, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    dst := make([]byte, aes.BlockSize) // зашифровываем
    aesblock.Encrypt(dst, src)
    fmt.Printf("encrypted: %x\n", dst)

    src2 := make([]byte, aes.BlockSize) // расшифровываем
    aesblock.Decrypt(src2, dst)
    fmt.Printf("decrypted: %s\n", src2)
}
```

Результат:
```
original: Слепой банкир
encrypted: dd0f35db82c59a211d58d04863e7cb4e
decrypted: Слепой б�
```

Обратите внимание, что в примере получается зашифровать только сообщение, совпадающее по длине с ключом шифрования. На практике это неудобно. 

Рассмотрим, как можно зашифровать сообщение произвольной длины. Нужен алгоритм, который делил бы данные на блоки, преобразовывал и подавал их на вход алгоритму AES. Для этого можно воспользоваться алгоритмом GCM (Galois/Counter Mode).

![](./assets/images/love.png)

Для работы GCM нужно дополнительно сгенерировать вектор инициализации из 12 байт. Вектор должен быть уникальным для каждой процедуры шифрования. Если переиспользовать один и тот же вектор, можно атаковать алгоритм, подавая на вход данные с разницей в один байт, и по косвенным признакам вычислить ключ шифрования.

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    // генерируем криптостойкие случайные байты в b
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    src := []byte("Ключ от сердца") // данные, которые хотим зашифровать
    fmt.Printf("original: %s\n", src)

    // будем использовать AES-256, создав ключ длиной 32 байта
    key, err := generateRandom(2 * aes.BlockSize) // ключ шифрования
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // NewCipher создает и возвращает новый cipher.Block. 
    // Ключевым аргументом должен быть ключ AES, 16, 24 или 32 байта 
    // для выбора AES-128, AES-192 или AES-256.
    aesblock, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // NewGCM возвращает заданный 128-битный блочный шифр
    aesgcm, err := cipher.NewGCM(aesblock)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // создаём вектор инициализации
    nonce, err := generateRandom(aesgcm.NonceSize())
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    dst := aesgcm.Seal(nil, nonce, src, nil) // зашифровываем
    fmt.Printf("encrypted: %x\n", dst)

    src2, err := aesgcm.Open(nil, nonce, dst, nil) // расшифровываем
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }
    fmt.Printf("decrypted: %s\n", src2)
}
```

Результат:
```
original: Ключ от сердца
encrypted: e5539431a0aeadf3936a5684b6ef38582a03e3d13c5d68f91b69292760ad65c29abe9a3a3ec60e265e22
decrypted: Ключ от сердца
```

___
Итак, у вас есть зашифрованное сообщение и пароль. Расшифруйте текст, если известно, что:
- сообщение зашифровано алгоритмами GCM и AES-256;
- ключ шифрования получен из пароля хеш-функцией SHA-256;
- для вектора инициализации используются последние байты ключа.

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
)

const (
    password = "x35k9f"
    msg      = `0ba7cd8c624345451df4710b81d1a349ce401e61bc7eb704ca` +
        `a84a8cde9f9959699f75d0d1075d676f1fe2eb475cf81f62ef` +
        `f701fee6a433cfd289d231440cf549e40b6c13d8843197a95f` +
        `8639911b7ed39a3aec4dfa9d286095c705e1a825b10a9104c6` +
        `be55d1079e6c6167118ac91318fe`
)

func main() {
    // допишите код
    // 1) получите ключ из password, используя sha256.Sum256
    // 2) создайте aesblock и aesgcm
    // 3) получите вектор инициализации aesgcm.NonceSize() байт с конца ключа
    // 4) декодируйте сообщение msg в двоичный формат
    // 5) расшифруйте и выведите данные

    // ...
}
```

Решение:
```go
    key := sha256.Sum256([]byte(password))

    aesblock, err := aes.NewCipher(key[:])
    if err != nil {
        panic(err)
    }
    aesgcm, err := cipher.NewGCM(aesblock)
    if err != nil {
        panic(err)
    }

    // создаём вектор инициализации
    nonce := key[len(key)-aesgcm.NonceSize():]

    encrypted, err := hex.DecodeString(msg)
    if err != nil {
        panic(err)
    }
    // расшифровываем
    decrypted, err := aesgcm.Open(nil, nonce, encrypted, nil)
    if err != nil {
        panic(err)
    }
    fmt.Println(string(decrypted))
```

```
Съешь ещё этих мягких французских булок, да выпей чаю
```

В этом уроке вы узнали о криптографии, хешировании и шифровании в Go и уже способны сделать свой сервис безопасным для пользователей. Далее вы познакомитесь с методами защиты данных и паролей.

## Дополнительные материалы

- [go.dev/math/rand](https://pkg.go.dev/math/rand) — документация пакета `math/rand`.
- [go.dev/crypto/sha256](https://pkg.go.dev/crypto/sha256) — документация пакета `crypto/sha256`.
- [go.dev/crypto/md5](https://pkg.go.dev/crypto/md5) — документация пакета `crypto/md5`.
- [go.dev/crypto/cipher](https://pkg.go.dev/crypto/cipher) — документация пакета `crypto/cipher`.
- [Cryptanalytic Attacks on Pseudorandom Number Generators](https://www.schneier.com/wp-content/uploads/2017/10/paper-prngs.pdf) — научная статья о видах атак на генераторы.
- [Educative | What is the AES algorithm?](https://www.educative.io/edpresso/what-is-the-aes-algorithm) — про алгоритм AES.
- [Practical Cryptography for Developers | Cipher Block Modes](https://cryptobook.nakov.com/symmetric-key-ciphers/cipher-block-modes) — про алгоритм GCM.
- [Practical Cryptography for Developers | HMAC and Key Derivation](https://cryptobook.nakov.com/mac-and-key-derivation/hmac-and-key-derivation) — про алгоритм HMAC.

# Авторизация: JSON Web Token

При создании приложения нужно помнить об информационной безопасности, особенно когда речь идёт о хранении персональных данных. 

Чтобы зайти в приложение банка, электронную почту или мессенджер, пользователь проходит процесс аутентификации: вводит логин и пароль и подтверждает, что имеет право получить доступ к запрашиваемой информации. Задача сервиса — защитить его данные и пароли. Сделать это помогает JSON Web Token, или `JWT` (произносится как «джот»).

В этом уроке расскажем, что такое JSON Web Token и из чего состоит структура `JWT`. На примере небольшого сервера покажем, как используется пакет `jwt-go` и как это всё работает в проектах на Go.

## Что такое JWT

JSON Web Token — это открытый стандарт, определяющий компактный и автономный способ безопасной передачи информации между клиентом и сервером в виде объекта JSON. Переданную таким образом информацию можно проверить. А ещё ей можно доверять, поскольку у такой информации есть цифровая подпись.

Самый распространённый алгоритм подписи `JWT` — HMAC. Это один из механизмов проверки целостности информации: он гарантирует, что данные, передаваемые или хранящиеся в ненадёжной среде, не были изменены посторонними. Другие популярные алгоритмы для подписи — RSA (от фамилий Rivest, Shamir и Adleman) и ECDSA (Elliptic Curve Digital Signature Algorithm).

Подписанные токены могут проверять целостность содержащихся в них данных, в то время как зашифрованные токены скрывают эти данные от других сторон.

Когда используется пара открытого и закрытого ключей, токен подписывается закрытым ключом. Такая подпись доказывает, что содержимое токена не менялось. Проверить этот факт может владелец открытого ключа. Закрытый ключ принадлежит стороне, которая подписала токен.

## Где используют JWT

`JWT` нужен для того, чтобы передавать данные, которым может доверять сервер.

Вот где чаще всего применяются веб-токены:
- **Авторизация**. Это наиболее распространённый сценарий использования `JWT`. После того как пользователь входит в систему, каждый последующий запрос включает `JWT`. Пользователь получает доступ к маршрутам, службам и ресурсам, разрёшенным с помощью этого токена. Единый вход — это функция, которая использует `JWT`.
- **Обмен информацией**. Веб-токены `JWT` — это способ безопасной передачи информации между сторонами. Так как `JWT` могут быть подписаны с использованием пар открытого и закрытого ключей, можно быть уверенным, что отправитель действительно является тем, за кого себя выдаёт.

## Из чего состоит структура JWT

Структура веб-токена JSON выглядит так:
`xxxxxxxxx.yyyyyyyyy.zzzzzzzzz`

Она состоит из трёх частей, разделённых точками:
1. Заголовок.
1. Полезная нагрузка (данные).
1. Подпись.

Разберём каждую часть подробнее.

### Заголовок

Заголовок (header) — это первая часть токена. Обычно он состоит из двух частей:
- алгоритм подписи: HMAC, SHA-256 или RSA;
- тип токена.

Выглядит это так:
```json
{
    "alg": "HS256",
    "typ": "JWT"
}
```

JSON кодируется в Base64Url для формирования первой части `JWT`.

### Полезная нагрузка

Полезная нагрузка (payload) — это вторая часть токена, которая содержит **утверждения**. Утверждения (claims) — это вспомогательная информация об объекте и дополнительных данных. Их делят на три группы.

Первая — **зарегистрированные** утверждения. К ним относятся стандартные, предопределённые `JWT` утверждения:
- `exp` - срок годности утверждения токена;
- `iat` — дата выпуска токена в unix-переменной;
- `iss` — создатель заявления;
- `aud` — получатель токена.

Вторая и третья группы — **публичные** и **частные** утверждения. Публичные — ещё один тип традиционных утверждений, которые добавляются в реестр `JWT`. Это имя, почта, временная зона действия токена. Частные утверждения определяют создатели приложения. Компания может назначить специфический `userId` всем своим пользователям — и это попадёт в утверждения.

Пример полезной нагрузки:
```json
{
    "name": "Vlad",
    "admin": true,
    "nickname": "lekan"
}
```

Как и заголовок, полезная нагрузка кодируется в `Base64Url` для формирования второй части `JWT`.

### Подпись

Подпись (signature) используется для проверки того, что сообщение не было изменено при передаче файла от одного пользователя другому. Благодаря ей можно идентифицировать отправителя `JWT`.

Чтобы создать часть подписи, нужно взять закодированные заголовок и полезную нагрузку, секретный ключ, алгоритм, указанный в заголовке, и всё это подписать.

Вывод `JWT` представляет собой три строки `Base64Url`, разделённые точками. Их можно легко передавать по HTTP.

Вот пример `JWT` c закодированным заголовком и полезной нагрузкой, подписанный секретным ключом:
![](./assets/images/chapter11_sprint4.png)

## Как работает JWT

После аутентификации, когда пользователь успешно вошёл в систему, введя свои учётные данные, возвращается токен `JWT`. Каждый раз, когда пользователь хочет получить доступ к защищённому ресурсу, пользовательский агент должен снова отправить `JWT`. Обычно это происходит в заголовке. 

При этом работает схема **Bearer authentication**. Аутентификация носителя, или аутентификация токена, — это схема аутентификации HTTP, в которой используются токены безопасности, называемые токенами носителя. Название «аутентификация носителя» означает «предоставление доступа носителю токена».

Содержимое заголовка будет выглядеть так: 
```
Authorization: Bearer <token>
```

Защищённые маршруты сервера проверяют допустимый `JWT` в заголовке `Authorization`. Если он присутствует, пользователю будет разрешён доступ к защищённым ресурсам.

**Важно**
Не рекомендуем помещать секретную информацию в токен, так как содержимое токена легко прочитать.

## JWT и Go: как создать сервер аутентификации

Чтобы разобраться, как это всё работает в Go, напишем простой сервер аутентификации. Начнём с самого простого.

Создайте папку проекта и войдите в неё. Не забудьте выполнить команду `go mod init`, чтобы создать файл `go.mod` для отслеживания зависимостей кода. Установите пакет `jwt-go`, выполнив команду:
```bash
go get -u github.com/golang-jwt/jwt/v4
```

Далее создайте файл `main.go`. Весь код будем писать в пакете `main` — так будет проще разобраться в особенностях `JWT` на Go. 

Объявим структуру утверждений, в которую будут входить зарегистрированные утверждения `JWT` и одно пользовательское утверждение `UserID`. Это будет полезная нагрузка в сервисе. Создадим основную функцию `main()`:
```go
package main

import (
    "github.com/golang-jwt/jwt/v4"
)

// Claims — структура утверждений, которая включает стандартные утверждения и 
// одно пользовательское UserID
type Claims struct {
    jwt.RegisteredClaims
    UserID int
}

func main() {
    
}
```

`jwt.RegisteredClaims` представляет собой структуру, в которую входит набор утверждений `JWT` c зарегистрированными именами утверждений из [спецификации](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1) `JWT`. Выглядит она так:
```go
type RegisteredClaims struct {
    
    // The `iss` (Issuer) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1
    Issuer string `json:"iss,omitempty"`

    // The `sub` (Subject) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2
    Subject string `json:"sub,omitempty"`

    // The `aud` (Audience) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3
    Audience ClaimStrings `json:"aud,omitempty"`

    // The `exp` (Expiration Time) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4
    ExpiresAt *NumericDate `json:"exp,omitempty"`

    // The `nbf` (Not Before) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5
    NotBefore *NumericDate `json:"nbf,omitempty"`

    // The `iat` (Issued At) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6
    IssuedAt *NumericDate `json:"iat,omitempty"`

    // the `jti` (JWT ID) claim. Смотрите в спецификации:
    // https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7
    ID string `json:"jti,omitempty"`
}
```

Эту структуру можно использовать саму по себе, но тогда дополнительные частные и публичные утверждения анализироваться не будут. Её встраивают в структуру утверждений, определённую пользователем.

Будем использовать только одно поле из спецификации `JWT` — `ExpiresAt`. Оно определит время жизни токена.

Теперь напишем функцию для создания токена, которая будет возвращать строку токена и, если что-то пойдёт не так, — ошибку. В `main()` вызовите эту функцию и выведите на экран токен. 

Также создадим две константы: первая будет содержать время действия токена, а вторая — секретный ключ. 

**Важно**
В реальных проектах секретный ключ не хранят в константе или переменной. Лучше использовать переменные окружения или базу данных. Секрет должен быть хорошо спрятан, а хранить его в исходном коде — не лучшая идея.

Применим алгоритм подписи HS256. Получим:
```go
package main

import (
    "github.com/golang-jwt/jwt/v4"
)

// Claims — структура утверждений, которая включает стандартные утверждения 
// и одно пользовательское — UserID
type Claims struct {
    jwt.RegisteredClaims
    UserID int
}

const TOKEN_EXP = time.Hour * 3
const SECRET_KEY = "supersecretkey"

func main() {
    tokenString, err := BuildJWTString()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(tokenString)
}

// BuildJWTString создаёт токен и возвращает его в виде строки.
func BuildJWTString() (string, error) {
    // создаём новый токен с алгоритмом подписи HS256 и утверждениями — Claims
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims {
        RegisteredClaims: jwt.RegisteredClaims{
            // когда создан токен
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(TOKEN_EXP)),
        },
        // собственное утверждение
        UserID: 1,
    })

    // создаём строку токена
    tokenString, err := token.SignedString([]byte(SECRET_KEY))
    if err != nil {
        return "", err
    }

    // возвращаем строку токена
    return tokenString, nil
}
```

Результат:
```
main.go:4:5: no required module provides package github.com/golang-jwt/jwt/v4; to add it:
	go get github.com/golang-jwt/jwt/v4
```

При определении поля времени жизни токена — `ExpiresAt` — использовали функцию `jwt.NewNumericDate(t time.Time) *NumericDate`. Она принимает стандартную библиотечную структуру [time.Time](https://pkg.go.dev/time#Time) и возвращает указатель на структуру [NumericDate](https://pkg.go.dev/github.com/golang-jwt/jwt/v4#NumericDate), которая выглядит так:
```go
type NumericDate struct {
    time.Time
}
```

Структура представляет числовое значение даты в JSON. Этого требует спецификация `JWT`.

Метод `jwt.NewWithClaims(method SigningMethod, claims Claims) *Token` создаёт новый токен с указанными методом подписи и утверждениями. В примере использовали метод подписи `HS256`, передав `jwt.SigningMethodHS256`.

Утверждения создаются с помощью структуры `Claims`, которую объявили. В неё входят зарегистрированное утверждение `ExpiresAt` и собственное утверждение `UserID`.

Теперь попробуем получить из строки токена полезную нагрузку, а именно — `UserID`. Для этого напишем ещё одну функцию, которая будет принимать строку токена и возвращать `ID` пользователя.

```go
func GetUserID(tokenString string) int {
    // создаём экземпляр структуры с утверждениями
    claims := &Claims{}
    // парсим из строки токена tokenString в структуру claims
    jwt.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (interface{}, error) {
        return []byte(SECRET_KEY), nil
    })

    // возвращаем ID пользователя в читаемом виде
    return claims.UserID
}
```

Чтобы сервис заработал, добавим в функцию `main()` строку для вывода `UserID` с вызовом новой функции — `fmt.Println(GetUserID(tokenString))`.

- Можно ещё раз повторить, что мы делаем?
- Мы создаём пустой экземпляр структуры `Claims`, куда можно сохранить всё, что находится в токене. Затем парсим строку токена с помощью функции `ParseWithClaims(tokenString string, claims Claims, keyFunc KeyFunc, options ...ParserOption) (*Token, error)`.
- Что такое `tokenString` и `claims`?
- `tokenString` — это строка токена, `claims` — утверждения, которые объявили ранее.
- А `keyFunc()` — это функция обратного вызова, которая используется методами `Parse()`?
- Верно! Сигнатура у неё такая: `func(*Token) (interface{}, error)`. Эта функция предоставляет секретный ключ для проверки токена. Она принимает проанализированный, но не проверенный токен. На основании его заголовка функция определяет, какой секретный ключ использовать для проверки, и возвращает секретный ключ или ошибку.
- А что вернём в конце?
- В конце вернём `UserID` из структуры `Claims`.

Если вы запустите проект, то увидите строку токена. На следующей строке будет `UserID`, равный `1`:
```shell
go run main.go
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEwODAwMDAwMDAwMDAwLCJVc2VySUQiOjF9.C1R1RcpPmnSFraHb_PfnLuVUl1UxeMmjGJIJ8NsHb3E
1
```

Изменим `UserID` в структуре `Claims` в функции `BuildJWTString()` на другое число и снова запустим программу:
```shell
go run main.go
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEwODAwMDAwMDAwMDAwLCJVc2VySUQiOjE3fQ.4btPNlxdXO25pbkuTmnb_B0jRV-7_rGUCMCxK9HwTS4
17
```

Обратите внимание, что вторая часть токена также изменилась.

## Как проверить валидность токена

Добавим код в функцию `GetUserID()`, чтобы выполнить проверку валидности токена:
```go
func GetUserID(tokenString string) int {
    claims := &Claims{}
    token, err := jwt.ParseWithClaims(tokenString, claims,
    func(t *jwt.Token) (interface{}, error) {
        return []byte(SECRET_KEY), nil
    })
    if err != nil {
        return -1
    }

    if !token.Valid {
        fmt.Println("Token is not valid")
        return -1
    }

    fmt.Println("Token is valid")
    return claims.UserID    
}
```

Чтобы проверить сам токен и узнать, есть ли в коде ошибки, добавим переменные `token` и `err`. Если при проверке возникнет ошибка, вернётся `-1`. Если токен окажется невалидным, тоже вернётся значение `-1`. Если ошибок нет и токен прошёл проверку, вернётся `ID` пользователя и выведется сообщение, что токен валидный.

Запустите код. Должен получиться такой вывод:
```shell
go run main.go
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEwODAwMDAwMDAwMDAwLCJVc2VySUQiOjE3fQ.4btPNlxdXO25pbkuTmnb_B0jRV-7_rGUCMCxK9HwTS4
Token is valid
17
```

## С какими проблемами можно столкнуться, используя JWT

`JWT` — это стандарт, который даёт большую гибкость в выборе алгоритмов подписи. Он прост в использовании и предоставляет сервисы без сохранения состояния. Но у любой медали — две стороны. При работе с `JWT` можно столкнуться с рядом проблем. Рассмотрим некоторые из них. 

1. С**лабые алгоритмы**. `JWT` предоставляет обширный набор алгоритмов, включая те, в которых уже известна уязвимость. Например RSA c PKCSv1.5, ECDSA. Разработчикам без достаточного опыта в области безопасности будет сложно разобраться, какой алгоритм лучше всего использовать.
1. **Возможность обойти проверку подписи**. `JWT` включает алгоритм подписи в заголовок токена, а значит, злоумышленник может просто установить заголовок `alg` в `none` и обойти процесс проверки подписи. Эта уязвимость была обнаружена и исправлена во многих библиотеках. Но всё же рекомендуем проверять подобные нюансы.
1. **Уязвимость**. Можно намеренно установить заголовок алгоритма с симметричным ключом, например HS256, зная, что на самом деле для проверки и подписи сервер использует алгоритм с асимметричным ключом. Таким образом, хакер может создать фальшивый токен администратора с заголовком алгоритма HS256 и подписать этот токен открытым ключом RSA сервера. А после — использовать его для доступа к ресурсам на сервере.

Предотвратить такие атаки можно. Достаточно, чтобы в коде сервера была проверка заголовка алгоритма токена. Заголовок должен совпадать с тем, который ваш сервер использует для подписи и проверки токенов. Добавим эту проверку в функцию G`etUserID()`:
```go
func GetUserID(tokenString string) int {
    claims := &Claims{}
    token, err := jwt.ParseWithClaims(tokenString, claims,
    func(t *jwt.Token) (interface{}, error) {
        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
        }
        return []byte(SECRET_KEY), nil
    })
    if err != nil {
        return -1
    }

    if !token.Valid {
        fmt.Println("Token is not valid")
        return -1
    }

    fmt.Println("Token os valid")
    return claims.UserID    
}
```

Запустите код — всё должно работать, как и прежде. Вывод не изменится. Добавили всего пару строк, но их достаточно, чтобы защитить сервер от серьёзной уязвимости.  

Итак, вы написали простой сервис аутентификации. Начали с объявления структуры утверждений и закончили функцией получения полезной нагрузки из строки токена со всеми необходимыми проверками на валидность. В процессе разработки этого сервиса вы познакомились с потенциальными проблемами при использовании `JWT` и узнали, как их можно избежать. 

Теперь расскажем, где можно хранить токены.

## Где хранить токены

Существует два распространённых способа хранения токенов в клиенте: локальное хранилище браузера (local storage) и куки-файлы (cookie). У каждого из них есть свои недостатки и преимущества. Сравним оба способа.

### Локальное хранилище

#### Преимущества

Основное преимущество локального хранилища в том, что им удобно пользоваться.

- Работа с локальным хранилищем организована удобно: тут используется чистый JavaScript. Если у приложения нет бэкенда, и вы полагаетесь на чужие API, не всегда можно запросить у этих API установку особых куки-файлов для вашего сайта.
- Удобно работать с API, которые требуют размещать токен доступа в заголовок запроса. Например, так: `Authorization Bearer ${access_token}`.

#### Недостатки

Главный недостаток локального хранилища — это его уязвимость к XSS-атакам.
- 
Во время XSS-атаки злоумышленник может запустить свой JavaScript-код на вашем сайте. Атакующий может получить доступ к токену, сохранённому в `localStorage`.
- Источником XSS-атаки может стать сторонний JavaScript-код, включённый в состав вашего сайта. В современных условиях почти невозможно разработать сайт, в котором не используются библиотеки сторонних разработчиков.

### Куки-файлы

#### Преимущества

Главное преимущество куки-файлов в том, что они недоступны из JavaScript и не так уязвимы перед XSS-атаками.

- Если использовать флаг `HttpOnly` и защищённые куки-файлы, то из JavaScript нельзя получить доступ к этим файлам. Даже если атакующий сможет запустить свой код на вашей странице, ему не удастся прочитать токен доступа из куки-файла.
- Куки автоматически отправляются в каждом HTTP-запросе к серверу.

#### Недостатки

Может случиться так, что токены в куки-файлах сохранить не удастся.

- Нельзя использовать большие `JWT`. Размер куки-файлов ограничен 4 Кб.
- Не всегда есть возможность передавать куки своему API-серверу. Бывает, что сторонний API требует размещения токена в заголовке `Authorization`. В таком случае вы не сможете хранить токены в куки-файлах.

*Вы приближаетесь к завершению первой темы спринта. Впереди вас ждёт инкремент, в котором вы добавите в сервис функцию аутентификации пользователя и реализуете механизм подписи данных с использованием алгоритма SHA256.* 

*Помните: для качественного усвоения материала важно давать себе время. Делайте перерывы, отдыхайте от экрана, пополняйте энергию — прогуляйтесь, перекусите или просто переключитесь на что-то другое.*

## Дополнительные материалы
- [go.dev/github.com/dgrijalva/jwt-go](https://pkg.go.dev/github.com/dgrijalva/jwt-go) — документация пакета `jwt-go`.
- [JSON Web Tokens](https://jwt.io/introduction) — официальная страница `JWT`.
- [RSA](https://ru.wikipedia.org/wiki/RSA) — про алгоритм RSA.
- [ECDSA](https://ru.wikipedia.org/wiki/ECDSA) — про алгоритм ECDSA.

# Инкремент 14

Добавьте в сервис функциональность аутентификации пользователя.

Сервис должен:
- Выдавать пользователю симметрично подписанную куку, содержащую уникальный идентификатор пользователя, если такой куки не существует или она не проходит проверку подлинности.
- Иметь хендлер `GET /api/user/urls`, который сможет вернуть пользователю все когда-либо сокращённые им URL в формате:
```json
[
    {
        "short_url": "http://...",
        "original_url": "http://..."
    },
    ...
]
```
- Если кука присутствует в запросе, но не содержит ID пользователя, хендлер должен возвращать HTTP-статус `401 Unauthorized`.
- При отсутствии сокращённых пользователем URL хендлер должен отдавать HTTP-статус `204 No Content`.

Получить куки запроса можно из поля `(*http.Request).Cookie()`, а установить — методом `http.SetCookie()`.

## Задание по треку «Сервис сбора метрик и алертинга»

Реализуйте механизм подписи передаваемых данных по алгоритму SHA256. Для этого посчитайте `hash` от всего тела запроса и разместите его в HTTP-заголовке `HashSHA256`.

Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте: `hash(value, key)`.

Агент:
- Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
- При наличии ключа агент должен вычислять хеш и передавать в HTTP-заголовке запроса с именем `HashSHA256`.

Сервер:
- Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
- При наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша.
- При несовпадении сервер должен отбрасывать полученные данные и возвращать `http.StatusBadRequest`.
- При наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в HTTP-заголовке ответа с именем `HashSHA256`.

*Внимание! Это учебный пример, в котором сделан акцент на закреплении пройденной темы, а не на безопасности. В реальной жизни использовать подпись таким образом не следует. Остаётся возможность передать серверу перехваченные ранее данные с корректным хешем (старое значение счётчика).*

# Что вы узнали

В этой теме вы познакомились с пакетами `hash`, `crypto` и научились:
- использовать криптостойкий генератор случайных чисел;
- хешировать, подписывать, зашифровывать и расшифровывать данные.

Также вы узнали, что такое JSON Web Token и для чего он используется. Изучили структуру `JWT`, на практике увидели, как работает веб-токен в Go. Разобрали уязвимые стороны `JWT` и способы хранения токена на стороне клиента. 

![](./assets/images/evolution_map_11.png)

