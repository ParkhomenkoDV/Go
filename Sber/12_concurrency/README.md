# Основы многопоточности

Первые компьютеры не отличались быстротой. Вычисления представляли собой длинную последовательность задач, которые выполнялись «в порядке живой очереди». Причём часть операций — в основном ввод-вывод — были медленнее вычислений. Процессор на таких этапах простаивал. 

Тогда возникла идея многозадачности. Вычисления стали делить на процессы, использующие общий ресурс. В таком режиме процессы выполняются конкурентно, то есть порядок их выполнения не предопределён. Представьте, что в привокзальном кафе наняли на работу ещё одну буфетчицу. Пока одна жарит яичницу, другая может резать салат или принимать заказы.

Сегодня умение писать многопоточные программы — одно из базовых требований к программистам. Сложно представить себе собеседование на Go-разработчика без вопросов о горутинах, каналах и мьютексах. Инструменты языка Go очень удобны для создания многопоточных приложений — именно поэтому он так популярен. Но реализовать такие сервисы без знаний о многопоточности в Go невозможно.

В заключительной теме курса расскажем:
- как устроена многопоточность в Go;
- как определяются и вызываются горутины;
- какие примитивы синхронизации есть в стандартной библиотеке;
- что такое каналы и как с ними работать;
- зачем нужны атомарные операции и как их использовать;
- какие паттерны многопоточного кода применяются в Go.

Представьте себе, как работал бы обычный веб-сервер без многопоточности. Вместо параллельной обработки HTTP-запросов он бы последовательно обрабатывал и отвечал на каждый запрос. В этом случае даже одна страница загружалась бы дольше из-за последовательной подгрузки изображений, скриптов и прочих ресурсов. А о тысячах запросах в секунду даже речи не идёт.

С активным развитием интернета и появлением многоядерных процессоров возникли новые требования к проектированию ПО, которое должно было эффективно использовать доступные ядра процессора. Язык Go успешно решает эту задачу, так как содержит готовые решения и инструменты для написания многопоточного кода.

## Процессы и потоки

Для начала разберёмся, что такое многопоточность. Выделим два ключевых понятия — процессы операционной системы и ядра процессора.

**Процесс** — это выполняющаяся программа и её ресурсы: heap-память, дескрипторы и так далее. Сам процесс хотя и хранит исполняемый код, не может его выполнить. За выполнение кода отвечают потоки.

**Поток выполнения** — это часть процесса. Каждый поток имеет доступ к контексту родительского процесса и кроме этого содержит собственные ресурсы: стек, специфические данные потока. 

В одном процессе может быть несколько потоков. Планировщик операционной системы распределяет потоки по **ядрам процессора**, чтобы дать каждому потоку равное время выполнения.

![](./assets/images/os_cpu.png)

Потоков значительно больше, чем ядер процессора. Когда планировщик переключает ядро с выполнения одного потока на другой, контекст предыдущего потока выгружается из памяти и загружаются данные потока, который будет выполняться. Если потоков слишком много, то на переключение между ними уходит много времени: из-за постоянных операций выгрузки-загрузки контекста программа выполняется дольше.

Поэтому некоторые современные языки программирования реализуют **легковесные потоки (green threads)**. Такие потоки легче, потому что легче их контекст. Они могут занимать меньший объём stack-памяти и использовать не все регистры. 

За планирование работы лёгких потоков отвечает среда выполнения — рантайм. Благодаря оптимизациям языка переключение между лёгкими потоками происходит быстрее, чем переключение между потоками операционной системы. Операционная система ничего не знает о легковесных потоках, поэтому в каждом языке могут быть свои особенности в реализации таких потоков.

## Многопоточность в Go

В Go реализована CSP-модель. Программа представляет собой множество одновременно работающих подзадач, которые общаются друг с другом с помощью каналов связи. 

В Go модель CSP реализована абстракциями:
- **Горутина (goroutine)** — это легковесный поток, который занимает гораздо меньше памяти, чем поток ОС. Среда выполнения Go может выполнять несколько горутин на одном потоке операционной системы и быстро переключаться с выполнения одной горутины на другую благодаря их малому размеру.
- **Канал (channel)** — это второй ключевой элемент в многопоточности на Go. На каналах построены все механизмы обмена и синхронизации потоков в Go. Одна горутина может записать данные в канал, а другая горутина — прочитать их.

![](./assets/images/goroutine_channel.png)

Планировщик рантайма Go управляет всеми создаваемыми горутинами. Он формирует очереди, каждая из которых привязана к потоку операционной системы. При работе программы очередная горутина берётся из очереди и вместе со своим контекстом отправляется на выполнение в поток ОС. 

Вытесняющий планировщик старается равномерно распределять процессорное время между горутинами. Таким образом, достигается иллюзия параллельности выполнения задач при количестве горутин, многократно превышающем количество доступных системных потоков. 

Принцип работы планировщика рантайма Go представлен на схеме:

![](./assets/images/goruntime.png)

## Проблемы многопоточности

Проблемы с многопоточностью возникают, когда несколько потоков работают с общими данными: обращаются к одной и той же памяти внутри процесса. Самая частая проблема — **состояние гонки (race condition)**.

![](./assets/images/race.png)

Все арифметические и логические действия в коде — это неатомарные операции. Если несколько потоков одновременно запустятся на разных ядрах процессора и начнут записывать данные в одну и ту же область памяти, возникнет конкуренция потоков. Один поток скопирует в свой регистр устаревшую копию данных, другой поток перезапишет данные и поменяет на свою версию и так далее.

![](./assets/images/operation.png)

Но есть способы предотвратить состояние гонки. Вот некоторые из них:
- **Мьютексы** (mutex — от mutual exclusion, что переводится как «взаимное исключение»). Мьютекс — это ресурс, который может быть занят только одним потоком. Для других потоков мьютекс заблокируется — они будут ждать, пока он освободится, чтобы продолжить работу.
- **Атомарные операции**. В современных процессорах запрограммированы команды, которые позволяют производить некоторые арифметические и логические действия атомарно. Используя атомарные операции, можно, к примеру, увеличивать целочисленный счётчик из нескольких потоков одновременно без дополнительных блокировок.
- **Обмен сообщениями**. Даёт потокам возможность обмениваться сообщениями или сигналами. Идея обмена сообщениями в том, чтобы создать очередь, в которую один поток может скопировать данные и из которой другой поток может прочитать свою копию.

В Go используются все три способа. Но самый предпочтительный — обмен сообщениями через каналы. Благодаря им можно написать более простой и надёжный многопоточный код. При передаче данных через канал не требуется дополнительное ограничение доступа к ресурсам, поэтому каналы позволяют минимизировать вероятность ошибки программиста.

Перечислим самые частые ошибки:
- **Взаимная блокировка (deadlock)**. Рассмотрим на примере. Представьте, что в буфете осталась одна ложка и одна вилка. Приходят два покупателя, каждому из которых нужна вилка и ложка. Они одновременно подходят к столовым приборам. Один берёт вилку, другой — ложку. Далее оба будут ждать, когда принесут другой прибор и не смогут начать есть свой заказ. Если в коде используются несколько мьютексов или каналов, то может возникнуть ситуация, когда все потоки ожидают сигналов один от другого и не могут продолжить работу.
- **Живая блокировка (livelock)**. Ещё один пример. Вы договорились созвониться с человеком в определённое время. Каждый раз, когда вы набираете его номер, он звонит вам. Вы отменяете вызов и ждёте какое-то время, но он делает то же самое. Живая блокировка — это cостояние программы, при котором потоки что-то делают, но не выполняют полезной работы. Например, два потока пытаются взять несколько мьютексов. Один берёт А и B, а другой B и A. Если второй мьютекс занят, каждый поток откатывается назад. Оба потока формально не будут заблокированы, но они будут постоянно то блокировать, то разблокировать мьютексы.
- **Голодание (starvation)**. Представьте, что человек едет с вокзала в аэропорт. Вместе с билетом на самолёт он взял priority pass (Priority Pass — международная программа доступа в VIP-залы аэропортов), прошёл вне очереди, но его не пускают — из-за большой сумки в ручной клади. Он ругается, занимает время борт-проводников. Из-за этого никто не может пройти дальше. В коде такая ситуация возникает, когда горутина захватывает мьютекс на большее время, чем ей нужно на самом деле. Из-за этого другим потокам приходится ждать разблокировки мьютекса.

___
Посмотрите на псевдокод и определите, к какой ошибке он может привести, если на двух ядрах процессора одновременно выполняются операции:
- `ПеревестиДеньги(счётВаси, счётПети, 10)`;
- `ПеревестиДеньги(счётПети, счётВаси, 15)`.

```go
func ПеревестиДеньги(счёт1, счёт2, сумма) {
    // функция блокироватьСчёт указывает на начало работы со счётом
    // eсли счёт уже заблокирован, то она будет ожидать его
    // разблокировки (функция разблокироватьСчёт)
    блокироватьСчёт(счёт1)
    счёт1.баланс -= сумма
    
    блокироватьСчёт(счёт2)
    счёт2.баланс += сумма
    
    разблокироватьСчёт(счёт2)
    разблокироватьСчёт(счёт1)
}
```

~~Взаимная блокировка (deadlock). (Могут одновременно заблокироваться счета Васи и Пети, как счёт1, и станет невозможна их блокировка, как счёт2.)~~
___
Соедините инструменты с задачами, которые они решают.

- Мьютексы = передача сообщений между горутинами
- Атомарные операции = изменение глобальной числовой переменной из нескольких потоков
- Каналы = передача сообщений между горутинами

В этом уроке вы рассмотрели основы многопоточного программирования. Ознакомились с наиболее распространёнными ошибками, возникающими при работе потоков, и узнали, как их избежать. Далее погрузимся в особенности многопоточного программирования на Go и рассмотрим, как использовать каналы для передачи данных между горутинами.

## Дополнительные материалы
- [Medium | Race condition и Data Race](https://medium.com/german-gorelkin/race-8936927dba20) — о состоянии гонки.
- [Medium | Deadlocks, Livelocks и Starvation](https://medium.com/german-gorelkin/deadlocks-livelocks-starvation-ccd22d06f3ae) — о взаимной блокировке, живой блокировке и голодании.

# Многопоточность в Go

## Горутины

Горутина — это функция, которая выполняется параллельно с другими функциями. В Go выполнить функцию — это `myFunc()`, a выполнить функцию в новой горутине — это `go myFunc()`. Да, всё так просто :) 

При вызове `go myFunc()` программа не дожидается завершения вызываемой функции, а выполняет идущий далее код.

```go
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 5; i++ {
        time.Sleep(time.Millisecond)        
        fmt.Print(s + ` `)
    }
}

func main() {
    // запустим две горутины с функцией say
    go say(`hello`)
    go say(`world`)
    // обычный вызов функции say
    say(`bye`)
}
```

Программа выведет примерно следующее:
```
world hello bye hello bye world bye hello world world hello bye bye
```

Как видите, горутины выполняются в произвольной последовательности. По умолчанию программа завершает работу, не дожидаясь окончательного выполнения горутин.

Если горутина содержит небольшое количество кода, который больше нигде не нужен, то можно определить её с помощью анонимной функции.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for _, v := range []string{"hello", "world", "bye"} {
        go func(s string) {
            for i := 0; i < 5; i++ {
                fmt.Print(s + ` `)
                time.Sleep(50 * time.Millisecond)
            }
        }(v)
    }
    time.Sleep(time.Second)
}
```
```
bye hello world world bye hello hello world bye bye hello world world bye hello 
```

## Планировщик горутин

- Как работает планировщик горутин?
- Представьте, что вам дали задачу — выкопать канаву. У вас есть команда из десяти человек, но на всех — всего три лопаты. Прежде чем начать работу, вы подумаете, как организовать процесс быстрее и эффективнее. Примерно этим и занимается планировщик Go.

Планировщик горутин — один из элементов рантайма языка. Он отвечает за выполнение горутин в потоках операционной системы. Планировщик равномерно распределяет процессорное время между горутинами, учитывая их сихронизацию и системные вызовы.

Планировщик горутин работает с тремя типами объектов:
- **Логический процессор**. Это ресурс, который объединяет поток операционной системы и очередь горутин. Для каждого логического процессора планировщик достаёт одну горутину из очереди и запускает её в потоке используя контекст логического процессора.
- **Поток операционной системы**. Это сущность операционной системы, в которой происходит процесс выполнения программного кода. Логический процессор закреплён за определённым потоком. Если горутина сделала системный вызов, который переводит поток в режим ожидания результата, например, чтение файла, то планировщик создаёт дополнительный поток операционной системы. На нём будут запускаться следующие горутины из очереди до разблокировки основного потока.
- **Горутина**.

По умолчанию количество логических процессоров берётся из значения переменной среды `GOMAXPROCS` и равно количеству логических ядер компьютера. Например, если у вас восьмиядерный компьютер, планировщик будет распределять горутины по восьми потокам ОС.

![](./assets/images/goroutines.png)

Теперь разберём, как можно влиять на работу горутин. Создатели Go стремятся использовать в планировщике универсальные алгоритмы и настройки. Поэтому для управления планировщиком используют следующие функции пакета `runtime`:
- `GOMAXPROCS(n int) int` — изменяет значение `GOMAXPROCS` и возвращает количество логических процессоров, которое было установлено до вызова функции. Если значение `GOMAXPROCS` больше, чем количество доступных ядер, скорость работы может не измениться. Чтобы узнать количество логических процессоров, укажите в параметре `0`.
- `Gosched()` — приостанавливает текущую горутину, чтобы планировщик переключился на другую. Работа этой горутины возобновится в порядке очерёдности. В версии Go 1.14 появился вытесняющий планировщик: он вытеснит зависшую по процессорному времени горутину. Таким образом, вызывать переключение горутин вручную не нужно.
- `LockOSThread()` — привязывает горутину к текущему потоку операционной системы. Эта функция пригодится при запуске кода на языке C, который требует выполнения в одном и том же потоке.

Стоит упомянуть ещё две функции:
- `NumCPU() int` возвращает количество логических ядер процессора. Можно использовать это значение для ограничения количества горутин.
- `NumGoroutine() int` возвращает количество запущенных горутин. Эта функция будет полезна при наблюдении за работой программы.

Рассмотрим пример, демонстрирующий работу этих функций:
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    fmt.Println("Ядер:", runtime.NumCPU())
    fmt.Println("Логических процессоров:", runtime.GOMAXPROCS(2), 
        "Горутин:", runtime.NumGoroutine())
    go func() {
        time.Sleep(100 * time.Millisecond)
    }()
    fmt.Println("Логических процессоров:", runtime.GOMAXPROCS(0), 
        "Горутин:", runtime.NumGoroutine())
}
```

На 8-ядерном процессоре получим вывод:
```
Ядер: 8
Логических процессоров: 8 Горутин: 1
Логических процессоров: 2 Горутин: 2
```

*Не удивляйтесь, что количество горутин отображается на одну больше, чем было запущено. Дело в том, что при запуске создаётся основная горутина, в которой выполняется код программы.*

## Типы sync.WaitGroup и sync.Once

Если вы запустили несколько горутин и хотите дождаться их завершения в основной функции, используйте тип `sync.WaitGroup`. Он представляет собой переменную со счётчиком горутин, завершения которых необходимо дождаться. Функциональность `WaitGroup` очень проста, состоит всего из трёх методов:
- `(*WaitGroup) Add(delta int)` — изменить значение счётчика на указанную величину;
- `(*WaitGroup) Done()` — уменьшить значение счётчика на единицу;
- `(*WaitGroup) Wait()` — ожидать, когда значение счётчика будет равно нулю.

Вот пример, в котором программа дожидается завершения запущенных горутин:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    const n = 5

    for i := 0; i < n; i++ {
        wg.Add(1) // инкрементируем счётчик, сколько горутин нужно подождать

        go func(i int) {
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("hi %d\n", i)
            // уменьшаем счётчик, когда горутина завершает работу
            wg.Done()
        }(i)
    }

    wg.Wait() // ждём все горутины
    fmt.Println("Всё готово")
}
```

Порядок выполнения горутин предсказать нельзя, но все они завершат свою работу. Вот один из результатов работы программы:
```
hi 0
hi 3
hi 4
hi 2
hi 1
Всё готово
```

___
Рассмотрите код и определите, каким будет результат работы программы. Выберите вариант ответа, не запуская пример. 

Подсказка: суммарное значение параметров во всех `Add()` должно совпадать с количеством вызовов `Done()`.

```go
func main() {
    var wg sync.WaitGroup

    n := 10
    wg.Add(n)
    for i := 0; i < n-1; i++ {
        go func(v int) {
            fmt.Println(v)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```

~~Программа зависнет или завершит работу с ошибкой. (В зависимости от платформы программа зависнет или возникнет ошибка (как правило, `fatal error: all goroutines are asleep - deadlock!`), потому что количество `Done()` меньше `n`.)~~
___

Если требуется выполнить определённое действие только один раз — например, вызвать функцию инициализации при первом обращении к структуре — в Go используется тип `sync.Once`.

Для этого создаётся переменная типа `sync.Once`, и у неё вызывается метод `Do()`, которому передаётся функция. Метод гарантирует, что переданная функция будет выполнена только один раз.

Перейдём к примеру. Напишем код, который вычитывает конфиг (англ. config) и инициализирует структуру при первом обращении к ней:
```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Config struct {
    once sync.Once
    vals map[string]string
}

func (c *Config) Get(k string) (string, bool) {
    c.once.Do(func() {
        // эта инициализация выполнится только один раз
        c.vals = map[string]string{
            "host": "127.0.0.1",
            "port": fmt.Sprintf("%d", rand.Intn(65535)),
        }
    })

    v, ok := c.vals[k]
    return v, ok
}

func main() {
    var cfg Config

    keys := []string{"host", "port", "port", "host", "port"}
    for _, k := range keys {
        go func(k string) {
            // в одной из горутин произойдёт инициализация cfg
            // остальные горутины будут ждать завершения инициализации
            v, ok := cfg.Get(k)
            if !ok {
                return
            }
            fmt.Printf("%s = %s\n", k, v)
        }(k)
    }

    time.Sleep(time.Second)
}
```

Результат:
```
port = 63058
host = 127.0.0.1
port = 63058
port = 63058
host = 127.0.0.1
```

Использование переменной типа `sync.Once` позволяет легко реализовать одноразовое выполнение определённых действий.

## Примитивы синхронизации

Горутины могут использовать одни и те же переменные или ресурсы во время работы. Если операции сводятся только к получению значений, они не нарушают целостность данных. Операции, которые можно выполнять одновременно в разных горутинах, называются **потокобезопасными**. Однако ситуация усложняется, когда горутины могут изменять данные.

Попробуйте запустить код, который заполняет мапу в нескольких горутинах.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    m := make(map[int]int)

    for i := 0; i < 5; i++ {
        go func() {
            for j := 0; j < 1000; j++ {
                if _, ok := m[j]; !ok {
                    m[j] = j
                }
            }
        }()
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```

С большой долей вероятности вы получите ошибку `concurrent map writes` или `concurrent map read and map write`, так как эта операция не потокобезопасна. Для решения этой проблемы нужно исключить другие операции с мапой. В этом помогает синхронизация горутин. Механизмы, которые позволяют горутине на время получить эксклюзивный доступ к данным, называются **примитивами синхронизации**.

Для синхронизации горутин можно использовать три примитива пакета `sync`:
- `sync.Mutex` — примитив, реализующий **мьютекс** в Go. Мьютекс — это механизм, который позволяет выполнить критические участки кода только одной горутиной;
- `sync.RWMutex` — особый вид мьютекса, который позволяет одновременно выполняться либо произвольному количеству операций чтения, либо одной операции записи;
- `sync.Cond` — переменная условия, которая останавливает горутину до получения сигнала.

Рассмотрим каждый элемент подробнее.

### Тип sync.Mutex

Мьютексы применяются, если горутина читает или изменяет данные, которые могут использоваться другим потоком. Для переменной типа `sync.Mutex` можно вызвать два метода:
- `(m *Mutex) Lock()` — блокирует мьютекс. Занять мьютекс может только одна горутина. Если другие горутины вызовут метод `Lock()` для занятого мьютекса, они будут ждать, пока он освободится.
- `(m *Mutex) Unlock()` — разблокирует мьютекс. Горутина должна освободить мьютекс сразу после того, как она закончила работу с общим ресурсом.

*Если вы применяете мьютексы для сихронизации чтения и записи определённых данных, следите за тем, чтобы не было горутин, работающих с этими данными без мьютекса. Иначе вы также будете получать ошибки конкурентного доступа.*

Покажем на примере, как используется `sync.Mutex`. Предположим, что есть два типа горутин. Одни постоянно меняют мапу, а другие читают. Использование мьютекса синхронизирует все обращения к мапе: только одна горутина может читать или менять её.

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func main() {
    var m sync.Mutex
    cache := map[int]int{}

    // горутины, которые изменяют мапу
    for i := 0; i < 10; i++ {
        go func() {
            for {
                m.Lock()
                cache[rand.Intn(5)] = rand.Intn(100)
                m.Unlock()
                time.Sleep(time.Second / 20)
            }
        }()
    }

    // горутины, которые читают мапу
    for i := 0; i < 10; i++ {
        go func() {
            for {
                m.Lock()
                fmt.Printf("%#v\n", cache)
                m.Unlock()
                time.Sleep(time.Second / 100)
            }
        }()
    }

    time.Sleep(1 * time.Second)
}
```

Результат:
```
map[int]int{}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4
...
39081 bytes truncated
```

У такого решения есть недостаток: оно неоптимально с точки зрения производительности. Из мапы данные читаются чаще, чем записываются в неё. Представьте такой случай: данные меняются очень редко, но обращаться к мапе мьютекс всё равно позволяет только одной горутине. Эту проблему решает тип `sync.RWMutex`.

### Тип sync.RWMutex

Этот тип мьютекса позволяет выполнять либо произвольное количество операций чтения, либо одну операцию записи. При этом нельзя выполнять две операции записи или одновременно запись и чтение.

Если горутине нужно изменить данные, то вызывается метод `Lock()`. Если горутина собирается читать данные, то она вызывает метод `RLock()`. Метод `RLock()` не даёт начать запись пока не будут завершены все операции чтения. Для разблокировки следует использовать соответствующие методы — `Unlock()` или `RUnlock()`.

![](./assets/images/RWMutex_methods.png)

Переделаем наш код таким образом, чтобы читать из мапы могли несколько горутин, а записывать в неё — только одна.

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func main() {
    // меняем тип мьютекса
    var m sync.RWMutex
    cache := map[int]int{}

    for i := 0; i < 10; i++ {
        go func() {
            for {
                // здесь остаются блокировки на запись
                m.Lock()
                cache[rand.Intn(5)] = rand.Intn(100)
                m.Unlock()
                time.Sleep(time.Second / 20)
            }
        }()
    }

    for i := 0; i < 10; i++ {
        go func() {
            for {
                // при чтении используем Rlock() и RUnlock()
                m.RLock()
                fmt.Printf("%#v\n", cache)
                m.RUnlock()
                time.Sleep(time.Second / 100)
            }
        }()
    }

    time.Sleep(1 * time.Second)
}
```

Результат:
```
map[int]int{}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
ma
...
39798 bytes truncated
```

*Обратите внимание! Для снятия блокировки на чтение и запись необходимо использовать разные методы: при `RLock()` используется `RUnlock()`, а при `Lock()` — `Unlock()`.*

___
Рассмотрите код. Каким будет результат его работы? Выберите правильный вариант. 

Подсказка: похожий пример мы рассматривали в начале главы о примитивах синхронизации.

```go
func main() {
    m := make(map[int]int)

    for i := 0; i < 100; i++ {
        go func(v int) {
            m[v] = 1
        }(i)
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```

~~Неопределённое поведение. (Выведет 100 или ошибку `fatal error: concurrent map writes`.)~~
___
Исправьте код из предыдущего задания так, чтобы программа выполнялась корректно и выводила `100`. Подсказка: используйте `sync.Mutex` при изменении мапы.

Решение:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var mu sync.Mutex
    m := make(map[int]int)

    for i := 0; i < 100; i++ {
        go func(v int) {
            mu.Lock()
            m[v] = v
            mu.Unlock()
        }(i)
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```
___

### Тип sync.Cond

Представьте, что горутина ждёт изменения определённых условий. Чтобы она постоянно не делала проверки, можно «усыпить» её до получения сигнала. Для этого используется **переменная условия** (от англ. condition variable) — примитив синхронизации, который блокирует один или несколько потоков до получения сигнала от другого потока.

Мьютекс блокирует другие горутины, а переменная условия работает по обратному принципу. Одна горутина переменной условия блокирует сама себя, а другим горутинам нужно её «пробудить», то есть освободить.

Переменная типа `sync.Cond` содержит локер-поле `L` типа `sync.Locker`, значениями которого выступают типы `*sync.Mutex` или `*sync.RWMutex`. Значение `L` передаётся в функции `sync.NewCond(l Locker) *Cond`. 

Есть три метода для работы с переменной условия:
- `(*Cond) Wait()` — разблокирует локер `L` и вводит текущую горутину в режим ожидания до получения сигнала. При получении сигнала локер `L` блокируется, и выполняется следующий после `Wait` код. Горутина должна заблокировать `L` перед вызовом `Wait`. Чаще всего встречаются такие варианты использования этого метода:
```go
// вариант 1
c.L.Lock()
c.Wait()
// производим нужные действия
// ...
c.L.Unlock()

// вариант 2
c.L.Lock()
for !condition() {
    c.Wait()
}
// производим нужные действия
// ...
c.L.Unlock()
```
- `(*Cond) Signal()` — разблокирует одну из ожидающих горутин, если такие есть.
- `(*Cond) Broadcast()` — разблокирует все горутины в очереди.

Диалог:
- Почему вызывается `Lock()` перед `Wait()`, а `Unlock()` — после? И обязательны ли эти вызовы?
- Дело в том, что в начале метода `Wait()` происходит разблокировка мьютекса `L` и текущая горутина встаёт в режим ожидания сигнала. Когда приходит сигнал, мьютекс `L` блокируется и `Wait()` завершает работу. Именно поэтому мы должны лочить мьютекс перед вызовом `Wait()` и не забывать освобождать его после.
- Нужен пример.
- `sync.Cond` встречается гораздо реже, чем мьютексы или каналы. `sync.Cond` удобно использовать, когда требуется многократное уведомление о событии неопределённого круга подпиcчиков (горутин).

Разберём пример. При изменении значения переменной нужно, чтобы её обработали несколько разных горутин (воркеров). Для оповещения всех ожидающих горутин будем использовать метод `Broadcast()`. Удобно, что функция, которая отправляет Broadcast-сигнал не знает, сколько запущено воркеров и не должна об этом думать:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func startWorkers(c *sync.Cond, val *int) {
    workerCount := 3

    for i := 0; i < workerCount; i++ {
        go func(workerId int) {
            c.L.Lock()
            for {
                c.Wait()
                // получили сигнал
                fmt.Printf("val %v processed by worker %v\n", *val, workerId)
            }
        }(i)
    }
}

func main() {
    var m sync.Mutex
    c := sync.NewCond(&m)
    val := 0
    startWorkers(c, &val)
    // ждём, чтобы стартанули все воркеры
    time.Sleep(100 * time.Millisecond)

    for i := 0; i < 4; i++ {
        m.Lock()
        val = i
        fmt.Printf("set val to %v\n", val)
        // отправляем сигнал всем воркерам
        c.Broadcast()
        m.Unlock()
        time.Sleep(time.Millisecond)
    }
}
```

Результат:
```
set val to 0
val 0 processed by worker 1
val 0 processed by worker 2
val 0 processed by worker 0
set val to 1
val 1 processed by worker 0
val 1 processed by worker 1
val 1 processed by worker 2
set val to 2
val 2 processed by worker 2
val 2 processed by worker 0
val 2 processed by worker 1
set val to 3
val 3 processed by worker 1
val 3 processed by worker 2
val 3 processed by worker 0
```

Перечислим ещё раз рассмотренные примитивы синхронизации. 

Если нужно, чтобы часть кода выполнялась только одной горутиной, то следует использовать примитив `sync.Mutex` и управлять его состоянием методами `Lock()` и `Unlock()`. 

Если происходят операции чтения и записи, то можно воспользоваться мьютексом типа `sync.RWMutex`, который позволяет горутинам одновременно читать данные и за счёт этого увеличивает скорость работы. 

Примитив `sync.Cond` даёт горутинам возможность обмениваться сигналами, в том числе отправлять сигнал всем подписчикам. Эта возможность используется редко: в большинстве случаев для обмена сигналами удобнее использовать каналы. О них мы расскажем в следующем уроке.

### Потокобезопасный контейнер для хранения объектов

Представьте ситуацию: в вашей программе постоянно нужно создавать временные объекты для небольшой задачи, после которго они становятся не нужны. 
Например, это могут быть длинные слайсы или буферы с байтами, которые используются для временного хранения данных.

Постоянное создание больших объектов с нуля требует выделения новой памяти, что может сказаться на производительности. 
В таких случаях удобно переиспользовать один объект несколько раз, чтобы избежать новых аллокаций.

Посмотрите на следующий пример. 
В функции foo каждый раз создается новый буфер.

```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    for i := 0; i < 10; i++ {
        foo()
    }
}

func foo() {
    // Создание нового буфера
    var buff bytes.Buffer
    
    buff.WriteString("Foo")
    buff.WriteString("Bar")
    buff.WriteString("Buzz")
    // ...
    
    fmt.Println(buff.String())
}
```

Результат:
```
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
```

### Тип sync.Pool

Одно из решений — переиспользовать один буфер несколько раз после создания. 
Для того, чтобы безопасно использовать один объект в нескольких потоков, в Go существует примитив `sync.Pool`.

Его методы `Put` и `Get` позволяют сохранить объект в пул и получить его обратно.

Посмотрите, как можно изменить предыдущий пример с использованием `sync.Pool`:
```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

var bufferPool = sync.Pool{
    // Функция New сработает, если в пуле нет объекта
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func main() {
    for i := 0; i < 10; i++ {
        foo()
    }
}

func foo() {
    buff := bufferPool.Get().(*bytes.Buffer)
    // В конце отправляем буфер обратно в пул, чтобы переиспользовать 
    defer bufferPool.Put(buff)
    
    // Сбрасываем буфер перед использованием, но выделенная память сохранится
    buff.Reset()
    
    buff.WriteString("Foo")
    buff.WriteString("Bar")
    buff.WriteString("Buzz")
    // ...
    
    fmt.Println(buff.String())
}
```

Результат:
```
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
```

В результате `sync.Pool` дает следующие преимущества:
- Потокобезопасный, можно получать объекты из нескольких потоков,
- Можно настроить функцию-конструктор, которая будет создавать начальные объекты (если контейнер пустой),

К тому же, `sync.Pool` позволяет сохранить несколько объектов. 
Однако пул не гарантирует порядок извлечения этих объектов с помощью метода `Get`.

В следующем сниппете показан пример, в котором в пул помещается и извлекается 10 чисел.

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var intPool sync.Pool
    for i := 0; i < 10; i++ {
        intPool.Put(i)
    }
    
    for i := 0; i < 10; i++ {
        fmt.Print(intPool.Get())
    }
}
```
Результат
```
0987654321
```

___
В следующем сниппете функция `concat` использует буфер для конкатенации (объединения нескольких строк в одну) массива строк. Измените код с использованием `sync.Pool`, чтобы переиспользовать буфер между несколькими конкатенациями.

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

type StringMerger struct {
    buffPool sync.Pool
}

func NewStringMerger() *StringMerger {
    return &StringMerger{}
}

func (s *StringMerger) Merge(strings ...string) string {
    // TODO Исправьте код так, чтобы один буфер мог быть переиспользован для разных конкатенаций.
    
    var buff bytes.Buffer
    for _, s := range strings {
        buff.WriteString(s)
    }
    return buff.String()
}

func main() {
    stringConcat := NewStringMerger()
    
    firstString := stringConcat.Merge("Foo", "Bar", "Buzz")
    secondString := stringConcat.Merge("This is ", "a test line.")
    thirdString := stringConcat.Merge("Hello", ", ", "World!")
    
    _, _ = firstString, secondString
    fmt.Println(thirdString)
}
```

Результат:
```
Hello, World!
```

Подсказка:
В конструкторе `NewStringMerger` настройте функцию создания нового буфера. 
Используйте этот буфер в функции `Merge`.

Решение:
```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

type StringMerger struct {
    buffPool sync.Pool
}

func NewStringMerger() *StringMerger {
    merger := StringMerger{}
    // Настраиваем функцию создания нового буфера
    merger.buffPool = sync.Pool{
        New: func() interface{} {
            return new(bytes.Buffer)
        },
    }
    return &merger
}

func (s *StringMerger) Merge(strings ...string) string {
    buff := s.buffPool.Get().(*bytes.Buffer)
    defer s.buffPool.Put(buff)
    
    buff.Reset()
    for _, s := range strings {
        buff.WriteString(s)
    }
    return buff.String()
}

func main() {
    stringConcat := NewStringMerger()
    
    firstString := stringConcat.Merge("Foo", "Bar", "Buzz")
    secondString := stringConcat.Merge("This is ", "a test line.")
    thirdString := stringConcat.Merge("Hello", ", ", "World!")
    
    _, _ = firstString, secondString
    fmt.Println(thirdString)
}
```
___
В последнем задании вы сможете проверить знания по мьютексам и `WaitGroup` — ключевым элементам при работе с горутинами. Найдите в программе ошибки и исправьте их. Программа должна завершаться без ошибок, а мапа всегда должна содержать 100 элементов.

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var (
        mu sync.Mutex
        wg sync.WaitGroup
    )
    m := make(map[int]int)
    for i := 0; i < 10; i++ {
        go func(v int) {
            wg.Add(1)
            for j := 0; j < 10; j++ {
                mu.Lock()
                defer mu.Unlock()

                k := 10*v + j
                m[k] = k
            }
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println(len(m))
}
```

Результат:
```
0
```

Решение:
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var (
        mu sync.Mutex
        wg sync.WaitGroup
    )
    m := make(map[int]int)
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(v int) {
            for j := 0; j < 10; j++ {
                k := 10*v + j
                mu.Lock()
                m[k] = k
                mu.Unlock()
            }
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println(len(m))
}
```
___

Это был непростой урок, но вы справились! Вы узнали, как создавать горутины и  разграничивать доступ из горутин к общим ресурсам. Работа с горутинами не всегда проста, но она действительно позволяет значительно ускорить выполнение программы и улучшить её производительность. В следующем уроке расскажем о работе с каналами и атомарными операциями.

## Дополнительные материалы
- [GO Scheduler: теперь не кооперативный?](https://habr.com/ru/post/502506/)
- [Как планировщик горутин управляет очередями.](https://calvinfeng.gitbook.io/gonotebook/concurrency/04-01-go-routines)
- [Как планировщик горутин работает с системными вызовами.](https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a)
- [Примитивы синхронизации в Go.](https://medium.com/german-gorelkin/synchronization-primitives-go-8857747d9660)
- [Concurrency Synchronization Techniques Provided in the sync Standard Package.](https://go101.org/article/concurrent-synchronization-more.html)
- [Планирование в Go: Часть I — Планировщик ОС.](https://habr.com/ru/post/478168/)
- [Планирование в Go: Часть II — Планировщик Go.](https://habr.com/ru/post/489862/)

# Каналы

В прошлом уроке вы познакомились с горутинами и примитивами синхронизации. В этом вы узнаете о ещё одном инструменте для работы с горутинами — **каналах** (channels). 

Каналы позволяют отправлять значения определённого типа между горутинами и могут синхронизировать их работу. Кроме каналов, в этом уроке рассмотрим оператор `select` и атомарные операции.

## Создание каналов

Каналы создаются функциями `make(chan тип_элемента)` или `make(chan тип_элемента,  ёмкость_канала)`. В первом случае создастся небуферизированный канал, а во втором — буферизированный. 

Операции чтения и записи в небуферизированный канал ожидают, когда другая горутина соответственно запишет или прочитает данные. Буферизированный канал накапливает данные. Когда канал пуст, горутина встаёт в режим ожидания при чтении. Когда канал полон, горутина встаёт в режим ожидания при записи. 

Работа с буферизированным каналом сводится к следующему: горутина записывает данные в канал, пока он не заполнится, а принимающая горутина может читать из этого канала, пока он не станет пустым. Когда канал полон, отправляющая горутина блокируется и ждёт, пока принимающая горутина не заберёт хотя бы одно значение. То же самое происходит и на другой стороне. Принимающая горутина находится в ожидании (блокируется), когда канал пустой, но оживает и начинает читать данные, как только в канал попадает хотя бы одно значение.

```go
// создать канал для значений типа int
ch1 := make(chan int)

// создать буферизированный канал для 5 элементов для значений типа string
ch2 := make(chan string, 5)

// создать канал для структур типа MyType
ch3 := make(chan MyType) 
```

Иногда необходимо получить текущее количество элементов в канале и его ёмкости. Например, если нужно проверить, полон ли канал, чтобы не посылать туда данные, а выполнить другие действия. Для этого используются функции `len(ch)` и `cap(ch)`.

Оператор `ch <- v` отправляет значение `v` в канал `ch`. Для получения значения из канала используется оператор `<- ch`. Этот вариант применяется, когда получаемое значение не важно. Если нужно сохранить значение, то слева указывается оператор присваивания `v := <-ch`.

Все важные отличия буферизированных и небуферизированных каналов представлены в таблице ниже.

![](./assets/images/bufer.png)

Теперь перейдём к примеру. Предположим, в программе есть два канала. В один записываются числа, в другой — отправляется сумма двух чисел из первого канала.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    chIn := make(chan int, 50)
    chOut := make(chan int)

    go func() {
        // горутина берёт числа из chIn
        for {
            left := <-chIn
            right := <-chIn
            // получаем два числа из chIn и записываем их сумму в chOut
            chOut <- left + right
        }
    }()

    go func() {
        // горутина берёт числа из chOut
        for {
            s := <-chOut
            // пусть обработка значений из chOut занимает какое-то время
            time.Sleep(20 * time.Millisecond)
            if s%10 == 1 {
                fmt.Printf("%d ", s)
            }
        }
    }()
    // отправляем сто чисел в канал chIn
    for i := 0; i < 100; i++ {
        chIn <- i
    }
    fmt.Printf("# ")
    time.Sleep(time.Second)
}
```

Вывод программы будет отличаться для разных значений ёмкости канала `chIn`.

```
// для chIn := make(chan int)
1 21 41 61 81 101 121 141 161 181 # 

// для chIn := make(chan int, 50)
1 21 41 61 81 # 101 121 141 161 181 

// для chIn := make(chan int, 100)
# 1 21 41 61 81 101 121 141 161 181
```

Чем больше ёмкость канала, тем быстрее происходит отправка чисел. При ёмкости равной 100 все числа сразу помещаются в канал.

Если горутина больше не будет отправлять значения в канал и на это нужно указать принимающим горутинам, то канал следует закрыть. Для этого нужно вызвать функцию `close(ch)`. Когда другие горутины попытаются получить значение из закрытого канала, им будут возвращаться нулевые значения. 

Если горутина отправит данные в закрытый канал, это приведёт к панике. Поэтому каналы закрывать не нужно, если нет увереннности, что туда не будут записываться данные. Когда канал перестанет использоваться и на него не будет активных ссылок, сборщик мусора освободит занимаемую каналом память независимо от того, закрыт он или нет.

Проверить, закрыт канал или нет, можно так: `i, ok := <-ch`. Если канал закрыт, значение `ok` будет равно `false`. Получение двух значений используется, когда необходимо отличать нулевое значение, отправленное в канал, от нулевого значения, возвращаемого из закрытого канала.

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int, 1)
    
    // так как ёмкость канала больше 0, то можно записать
    // одно значение не ожидая, когда оно прочитается
    ch <- 10

    // попробуем закрыть канал, в котором есть значение
    close(ch)

    fmt.Println("len =", len(ch), "cap =", cap(ch))
    
    v, opened := <-ch
    fmt.Println(v, opened, "len =", len(ch))
    
    v, opened = <-ch
    fmt.Println(v, opened, "len =", len(ch))
}
```

Вывод программы показывает, что канал закрылся только после того, как было прочитано значение и его размер стал равен 0.

```
len = 1 cap = 1
10 true len = 0
0 false len = 0 
```

Напомним, что канал создаётся функцией `make()`. Если вы просто определите переменную типа `chan`, она, как и в случае со слайсами, будет равна `nil`. Таким образом, есть три состояния канала: 
- равен `nil`;
- инициализирован и не закрыт;
- закрыт.

Изучите таблицу. В ней — результаты основных операций для каждого состояния:
![](./assets/images/channels.png)

Если ни одна горутина не может продолжить работу, рантайм завершает программу с ошибкой `fatal error: all goroutines are asleep - deadlock!`.

Рассмотрим использование каналов на практике. Допустим, вы разрабатываете сервис, который меняет размер изображения. Ресайзинг картинок — долгая операция. Возникла идея запустить N горутин, где N равно количеству ядер процессора. По задумке каждая горутина будет получать картинку из очереди и менять размер.

В примере рассмотрим три сущности:
- `Queue` — очередь задач, которую реализуем с помощью каналов;
- `Resizer` — модуль, который ресайзит картинки;
- `Worker` — воркер, который вытаскивает задачу из очереди и обрабатывает её.

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

// Task содержит имя файла для конвертации
type Task struct {
    Filename string
}

// Queue - это очередь задач
type Queue struct {
    ch chan *Task
}

func NewQueue() *Queue {
    return &Queue{
        ch: make(chan *Task, 1),
    }
}

func (q *Queue) Push(t *Task) {
    // добавляем задачу в очередь
    q.ch <- t
}

func (q *Queue) PopWait() *Task {
    // получаем задачу
    return <-q.ch
}

type Resizer struct {
    Width  uint32
    Height uint32
}

func NewResizer(w, h uint32) *Resizer {
    return &Resizer{
        Width:  w,
        Height: h,
    }
}

func (r *Resizer) Resize(filename string) error {
    // пропустим реализацию
    time.Sleep(10 * time.Millisecond)
    return nil
}

type Worker struct {
    id      int
    queue   *Queue
    resizer *Resizer
}

func NewWorker(id int, queue *Queue, resizer *Resizer) *Worker {
    w := Worker{
        id:      id,
        queue:   queue,
        resizer: resizer,
    }
    return &w
}

func (w *Worker) Loop() {
	for {
        t := w.queue.PopWait()

        err := w.resizer.Resize(t.Filename)
        if err != nil {
            fmt.Printf("error: %v\n", err)
            continue
        }

        fmt.Printf("worker #%d resized %s\n", w.id, t.Filename)
    }
}

func main() {
    queue := NewQueue()

    for i := 0; i < runtime.NumCPU(); i++ {
        w := NewWorker(i, queue, NewResizer(1024, 1024))
        go w.Loop()
    }

    for i := 0; i < 50; i++ {
        imagefile := fmt.Sprintf("gopher%d.jpg", i)
        queue.Push(&Task{Filename: imagefile})
    }

    time.Sleep(time.Second)
}
```

Таким образом, используя каналы, удалось реализовать очередь с минимальным количеством кода.

___
Проверьте себя. Не запуская код, определите, каким будет результат его выполнения.
~~В результате получим взаимную блокировку (Взаимная блокировка возникнет потому, что нет другой горутины, которая читает канал.)~~
___

При запуске следующей программы происходит ошибка (взаимная блокировка). Найдите причину и исправьте её. Программа должна выводить 7.

```go
package main

import "fmt"

func main() {
    var ch chan int

    go func() {
        ch <- 7
    }()
    v := <-ch
    fmt.Println(v)
}
```

Подсказка:
Нужно создать канал функцией `make()`.

Решение:
```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch <- 7
    }()
    v := <-ch
    fmt.Println(v)
}
```
___

## Операторы для работы с каналами

Оператор `range` позволяет в цикле принимать значения из канала до тех пор, пока он не будет закрыт. Например, горутина должна постоянно получать значения из канала и обрабатывать их определённым образом. `range` используется в канале, который закрывается, иначе он будет эквивалентен бесконечному циклу.

```go
for i := range ch {
    // тело цикла
}
```

Этот оператор эквивалентен такому циклу:
```go
for {
    i, ok := <-ch
    if !ok {
        break
    }
    // тело цикла
}
```

Пример кода:
```go
package main

import "fmt"

func fibonacci(n int, ch chan int) {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        ch <- x // посылаем значения в канал
        x, y = y, x+y
    }

    close(ch) // закрываем канал
}

func main() {
    ch := make(chan int, 7)
    // специально делаем буфер канала меньше,
    // чем количество чисел Фибоначчи
    go fibonacci(15, ch)

    for i := range ch {
        // считываем значения из канала, пока он не будет закрыт
        fmt.Printf("%d ", i)
    }
}
```

Программа выведет: 
```
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

Как уже было сказано, горутина может заблокироваться и ждать готовности канала. Но что делать, если надо ждать сразу несколько каналов: в одном — результата функции, в другом — сигнала, что нужно завершить программу? Можно использовать оператор `select`.

Изучите его синтаксис:
```go
select {
case x := <-ch1:
    // сценарий выполнится, если быстрее всего новое значение окажется в канале ch1
case y := <-ch2:
    // сценарий выполнится, если быстрее всего новое значение окажется в канале ch2
case ch3 <- z:
    // сценарий выполнится, если быстрее отправим значение в канал ch3
}
```

Если не выполняется ни одно из условий, `select` переходит в режим ожидания. Когда без блокировки нужно проверить, есть ли новые сообщения, необходимо добавить секцию `default`. Она выполнится вместо перехода в режим ожидания, и управление перейдёт к следующему после `select` коду.

```go
select {
case x := <-ch1:
    // ...
case ch3 <- z:
    // ...
default:
    // код выполнится, если не подошёл ни один из вариантов выше
    // ...
}
```

**Важно**
В операторе `select` выполняется только один из блоков `case`. Если несколько условий срабатывают одновременно, то вариант выбирается случайным образом: порядок `case` не имеет значения. Если нужно постоянно проверять условия оператора, поместите `select` в цикл.

Оператор `select` позволяет использовать `break` внутри секций, но `break` обеспечивает только выход из `select`. Чтобы прервать цикл с `select`, применяют следующие подходы:
- выход из функции по `return`;
- изменение условия, которое проверяется в цикле;
- `break` с указанием метки цикла.

Пример:
```go
package main

import "fmt"

func fibonacci(ch chan int, quit chan bool) {
    x, y := 0, 1
loop: // метка цикла
    for {
        select {
        case ch <- x: // ждём, когда заберут значение из канала,
                      // чтобы сгенерировать следующее
            x, y = y, x+y
        case <-quit:  // параллельно ждём сигнала об окончании работы
            break loop
        }
    }
    fmt.Println("Выход")
}

func main() {
    ch := make(chan int)
    quit := make(chan bool)

    go func() {
        for i := 0; i < 15; i++ {
            fmt.Println(<-ch)
        }
        // подаём сигнал об окончании работы
        quit <- true
    }()

    fibonacci(ch, quit)
}
```

Результат:
```
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
Выход
```

`select` может принимать данные из нескольких каналов, но некоторые из этих каналов могут закрыться в процессе работы. Так как из закрытого канала возвращаются нулевые значения, `select` по-прежнему будет выполнять соответствующий ему блок `case`. Чтобы этого избежать, можно присвоить закрытому каналу `nil` — тогда оператор `select` будет пропускать варианты с нулевыми каналами.

```go
for {
    select {
    // этот вариант будет пропускаться, если ch == nil
    case v, ok := <-ch:
        if !ok {
            ch = nil
            continue
        }
        // ...
    }
}
```

Разберём, в каких случаях можно использовать закрытые каналы. Предположим, надо завершить работу программы и оповестить об этом горутины, в которых есть оператор `select`. Для этого создадим канал `done := make(chan struct{})`. Его будут читать все горутины. 

Каналы с пустой структурой часто используются для оповещений о событиях. Если отправить пустую структуру в канал `done`, то его получит только одна горутина. Но нужно отправить сигнал всем горутинам. Так как закрытый канал отдаёт нулевые значения в неблокирующем режиме, достаточно закрыть канал, чтобы оповестить о событии все потоки.

```go
package main

var done = make(chan struct{})

func worker(wg *sync.WaitGroup, i int) {
    for {
        select {
        case <-done:
            fmt.Println("Завершаем", i)
            wg.Done()
            return
        default:
            fmt.Println(i)
        }
        time.Sleep(50 * time.Millisecond)
    }
}

func main() {
    var wg sync.WaitGroup

    // создаём горутины
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go worker(&wg, i)
    }
    time.Sleep(1 * time.Second)
    // сообщаем горутинам о завершении работы
    close(done)
    // ждём завершения всех горутин
    wg.Wait()
}
```

___
Ниже приведена программа, которая получает значения из одного канала и отправляет удвоенные значения в другой канал. Но есть одна проблема: иногда последние значения не печатаются. Пример вывода: `0 2 4 6 8 10 12 14 16 18 20 22 24`. Исправьте код, чтобы он работал правильно. Изменения нужно внести только в горутины.

```go
package main

import "fmt"

func main() {
    chIn := make(chan int)
    chOut := make(chan int)
    quit := make(chan struct{})

    go func() {
        for i := 0; i < 15; i++ {
            chIn <- i
        }
        close(quit)
    }()
    go func(){
       	var x int
        for {
            select {
            case x = <-chIn:
                chOut <- x * 2
            case <-quit:
                return
            }
        }
    }()
    go func() {
        for {
            fmt.Printf("%d ", <-chOut)
        }
    }()
    <-quit
}
```

Подсказка:
Можно обойтись без `select` и использовать операторы `range`.

Решение:
```go
package main

import "fmt"

func main() {
    chIn := make(chan int)
    chOut := make(chan int)
    quit := make(chan struct{})

    go func() {
        for i := 0; i <= 15; i++ {
            chIn <- i
        }
        close(chIn)
    }()
    go func(){
           for x := range chIn {
            chOut <- x * 2
        }
        close(chOut)
    }()
    go func() {
        for x := range chOut {
            fmt.Printf("%d ", x)
        }
        quit <- struct{}{}
    }()
    <-quit
}
```
___

## Однонаправленные каналы

Часто каналы передаются в аргументах функций. Внутри функций каналы используются только для отправки или получения данных. Если передаваемый в аргументе канал будет использоваться только для чтения или записи, то для параметра функции можно указать однонаправленный тип канала:
- `<-chan` — только для получения данных. Например, `par <-chan int`;
- `chan<-` — только для отправки данных. Например, `par chan<- string`.

Пример использования однонаправленных каналов:
```go
package main

import (
    "fmt"
    "strings"
)

// Generate отправляет в канал out односимвольные строки.
func Generate(out chan<- string) {
    for ch := 'a'; ch <= 'z'; ch++ {
        out <- string([]rune{ch})
    }
    close(out)
}

// Process читает строки из канала in, переводит их в верхний регистр
// и отправляет в канал out.
func Process(in <-chan string, out chan<- string) {
    for v := range in {
        out <- strings.ToUpper(v)
    }
    close(out)
}

func main() {
    lower := make(chan string)
    upper := make(chan string)
    go Generate(lower)
    go Process(lower, upper)

    // выводим строки из канала upper по мере получения
    for s := range upper {
        fmt.Print(s)
    }
}
```

Программа выведет: 
```
ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

___
Представьте, что вы написали простенький код с каналами. Пока вы пили чай, ваша кошка прошлась по клавиатуре и удалила часть кода: надеемся, она сделала это неспециально. Теперь вам нужно восстановить текст программы.

```go
package main

import "fmt"

func process(in1, in2 <-chan int, out chan<- int) {
loop:
	for {
		select {
		case x, ok := <-in1:
			if !ok {
				break 
			}
			out <- x * 2
		case x, ok := :
			if !ok {
				break loop
			}
			out <- x * 3
		}
	}
	close()
}

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	chout := make(chan int)

	go func() {
		for i := 0; i <= 20; i++ {
			select {
			case <- i:
			case ch2 <- i:
			}
		}
		close(ch1)
		close()
	}()
	go process(ch1, ch2, )
	for i := range chout {
		fmt.Printf("%d ", i)
	}
}
```

Подсказка:
Были удалены следующие фрагменты: `loop`, `<-in2`, `out`, `ch1`, `ch2`, `chout`.

Решение:
```go
package main

import "fmt"

func process(in1, in2 <-chan int, out chan<- int) {
loop:
    for {
        select {
        case x, ok := <-in1:
            if !ok {
                break loop
            }
            out <- x * 2
        case x, ok := <-in2:
            if !ok {
                break loop
            }
            out <- x * 3
        }
    }
    close(out)
}

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    chout := make(chan int)

    go func() {
        for i := 0; i <= 20; i++ {
            select {
            case ch1 <- i:
            case ch2 <- i:
            }
        }
        close(ch1)
        close(ch2)
    }()
    go process(ch1, ch2, chout)
    for i := range chout {
        fmt.Printf("%d ", i)
    }
}
```

## Атомарные операции

Теперь разберём, что такое атомарные операции. Но для начала рассмотрим пример, в котором будем увеличивать значение общего счётчика одновременно из разных горутин:
```go
package main

import (
    "fmt"
    "sync"
)

func count() {
    var counter int64

    var wg sync.WaitGroup

    // горутины увеличивают значение счётчика
    for i := 0; i < 25; i++ {
        wg.Add(1)
        go func() {
            for i := 0; i < 2000; i++ {
                counter++
            }
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Printf("%d ", counter)
}

func main() {
    // делаем несколько попыток
    for i := 0; i < 5; i++ {
        count()
    }
}
```

Если запустить эту программу, то она выведет примерно следующее:
```
41131 47906 42555 50000 47864
```

Это происходит из-за поэтапного увеличения счётчика:
1. Берём текущее значение переменной.
1. Увеличиваем его на 1.
1. Записываем новое значение в переменную.

Эти операции очень быстрые. Но если имеется много горутин, которые постоянно меняют значение переменной, то может возникнут такая ситуация:
- горутина 1: получает значение (1);
- горутина 1: увеличивает его на 1 (2);
- горутина 2: получает значение (1);
- горутина 1: записывает значение (2);
- горутина 2: увеличивает значение на 1 (2);
- горутина 2: записывает значение (2).

Обе горутины увеличивали счётчик, но он изменился только на 1. В таких случаях нужно использовать мьютексы. Однако при очень большом количестве операций, мьютексы будут замедлять работу программы. Поэтому для изменения целочисленных значений были добавлены более быстрые **атомарные операции**.

Атомарные операции — это такие операции, которые выполняются за один шаг относительно других горутин. Для корректной работы рассмотренного примера необходимо, чтобы изменение счётчика было атомарной операцией. Только в таком случае можно избежать одновременного увеличения его двумя горутинами. 

В пакете `sync/atomic` стандартной библиотеки реализованы атомарные операции для типов: `int32`, `int64`, `uint32`, `uint64`, `uintptr`, `unsafe.Pointer`.

Ниже перечислены функции для типа `int64`. Пакет `sync/atomic` содержит аналогичные функции и для других типов.

- `AddInt64(addr *int64, delta int64)` — добавить `delta` к значению `addr`. Функция возвращает новое значение.
```go
    var addr int64
    atomic.AddInt64(&addr, 1)
```
- `CompareAndSwapInt64(addr *int64, old int64, new int64)` — сравнить значение `addr` с `old` и заменить на `new`, если они равны. Функция возвращает `true`, если значение `addr` было заменено.
```go
    var addr int64
    atomic.CompareAndSwapInt64(&addr, 0, 77)
```
- `SwapInt64(addr *int64, new int64)` — изменить значение `addr` на `new`. Функция возвращает предыдущее значение.
```go
    var addr int64
    old := atomic.SwapInt64(&addr, 3)
```
- `LoadInt64(addr *int64)` — разыменовать указатель и возвратить значение.
```go
    var addr int64
    val := atomic.LoadInt64(&addr)
```
- `StoreInt64(addr *int64, val int64)` — записать значение по указателю.
```go
    var addr int64
    atomic.StoreInt64(&addr, 5)
```

Переделаем пример с счётчиком, используя атомарные операции.
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func count() {
    var counter int64

    var wg sync.WaitGroup

    // горутины увеличивают значение счётчика
    for i := 0; i < 25; i++ {
        wg.Add(1)
        go func() {
            for i := 0; i < 2000; i++ {
                atomic.AddInt64(&counter, 1)
            }
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Printf("%d ", atomic.LoadInt64(&counter))
}

func main() {
    // делаем несколько попыток
    for i := 0; i < 5; i++ {
        count()
    }
}
```

Сейчас программа выводит ожидаемый результат:
```
50000 50000 50000 50000 50000 
```

Также в пакете определены типы-обёртки: `atomic.Bool`, `atomic.Int32`, `atomic.Int64`, `atomic.Pointer` и так далее — с соответствующими методами. Перечислим методы для типа `atomic.Bool`:
```go
// CompareAndSwap сравнивает значение с `old` и в случае равенства заменяет
// на `new`. Метод возвращает `true`, если значение было заменено.
func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)

// Load возвращает логическое значение.
func (x *Bool) Load() bool

// Store записывает значение в переменную.
func (x *Bool) Store(val bool)

// Swap изменяет значение на указанное и возвращает предыдущее значение.
func (x *Bool) Swap(new bool) (old bool)
```

Перепишем пример со счётчиком используя тип `atomic.Int64`.
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func count() {
    var counter atomic.Int64

    var wg sync.WaitGroup

    // горутины увеличивают значение счётчика
    for i := 0; i < 25; i++ {
        wg.Add(1)
        go func() {
            for i := 0; i < 2000; i++ {
                counter.Add(1)
            }
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Printf("%d ", counter.Load())
}

func main() {
    // делаем несколько попыток
    for i := 0; i < 5; i++ {
        count()
    }
}
```

Результат:
```
50000 50000 50000 50000 50000 
```

Согласитесь, что код стал выглядеть приятнее.

___
Перед вами код, в котором горутины увеличивают значение счётчика. Чаще всего программа выводит неверное значение. Исправьте код так, чтобы значение счётчика было правильным.

```go
package main

import (
    "fmt"
    "sync"
)

var counter int64

func worker(wg *sync.WaitGroup) {
    for i := 0; i < 10000; i++ {
        counter++
    }
    wg.Done()
}
func main() {
    var wg sync.WaitGroup
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go worker(&wg)
    }
    wg.Wait()
    // программа должна выводить 200000
    fmt.Println(counter)
}
```

Решение:
```go
// цикл в функции worker нужно изменить так
for i := 0; i < 10000; i++ {
    atomic.AddInt64(&counter, 1)
} 
```
___
Какая функция пакета `atomic` атомарно реализует то же, что функция `Foo`?
```go
func Foo(i *int64, v int64) int64 {
    ret = *i
    *i = v
    return ret
}
```

~~`SwapInt64` присваивает новое значение и возвращает предыдущее.~~
___
Не запуская код, определите, что выведет программа.
```go
func main() {
    ch := make(chan string, 1)
    ch <- "OK"
    fmt.Println(<-ch)
}
```

~~Взаимная блокировка не возникнет, так как канал буферизированный.~~
___

В этом уроке вы изучили основные принципы работы с каналами в Go. Рассмотрели, как создавать каналы, отправлять и получать данные через них, а также использовать операторы `select` и `range` для управления потоком данных. Вы изучили атомарные операции и узнали, как их применять в горутинах. Все эти знания пригодятся при создании эффективных и надежные мнопоточных программ.

## Дополнительные материалы

- [Channels in Go.](https://go101.org/article/channel.html)
- [Анатомия каналов в Go.](https://habr.com/ru/post/490336/)
- [Package sync/atomic.](https://pkg.go.dev/sync/atomic)

# Паттерны многопоточности: Генератор, Стоп-Кран, Паттерн обработки ошибок

