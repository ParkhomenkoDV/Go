# Основы многопоточности

Первые компьютеры не отличались быстротой. Вычисления представляли собой длинную последовательность задач, которые выполнялись «в порядке живой очереди». Причём часть операций — в основном ввод-вывод — были медленнее вычислений. Процессор на таких этапах простаивал. 

Тогда возникла идея многозадачности. Вычисления стали делить на процессы, использующие общий ресурс. В таком режиме процессы выполняются конкурентно, то есть порядок их выполнения не предопределён. Представьте, что в привокзальном кафе наняли на работу ещё одну буфетчицу. Пока одна жарит яичницу, другая может резать салат или принимать заказы.

Сегодня умение писать многопоточные программы — одно из базовых требований к программистам. Сложно представить себе собеседование на Go-разработчика без вопросов о горутинах, каналах и мьютексах. Инструменты языка Go очень удобны для создания многопоточных приложений — именно поэтому он так популярен. Но реализовать такие сервисы без знаний о многопоточности в Go невозможно.

В заключительной теме курса расскажем:
- как устроена многопоточность в Go;
- как определяются и вызываются горутины;
- какие примитивы синхронизации есть в стандартной библиотеке;
- что такое каналы и как с ними работать;
- зачем нужны атомарные операции и как их использовать;
- какие паттерны многопоточного кода применяются в Go.

Представьте себе, как работал бы обычный веб-сервер без многопоточности. Вместо параллельной обработки HTTP-запросов он бы последовательно обрабатывал и отвечал на каждый запрос. В этом случае даже одна страница загружалась бы дольше из-за последовательной подгрузки изображений, скриптов и прочих ресурсов. А о тысячах запросах в секунду даже речи не идёт.

С активным развитием интернета и появлением многоядерных процессоров возникли новые требования к проектированию ПО, которое должно было эффективно использовать доступные ядра процессора. Язык Go успешно решает эту задачу, так как содержит готовые решения и инструменты для написания многопоточного кода.

## Процессы и потоки

Для начала разберёмся, что такое многопоточность. Выделим два ключевых понятия — процессы операционной системы и ядра процессора.

**Процесс** — это выполняющаяся программа и её ресурсы: heap-память, дескрипторы и так далее. Сам процесс хотя и хранит исполняемый код, не может его выполнить. За выполнение кода отвечают потоки.

**Поток выполнения** — это часть процесса. Каждый поток имеет доступ к контексту родительского процесса и кроме этого содержит собственные ресурсы: стек, специфические данные потока. 

В одном процессе может быть несколько потоков. Планировщик операционной системы распределяет потоки по **ядрам процессора**, чтобы дать каждому потоку равное время выполнения.

![](./assets/images/os_cpu.png)

Потоков значительно больше, чем ядер процессора. Когда планировщик переключает ядро с выполнения одного потока на другой, контекст предыдущего потока выгружается из памяти и загружаются данные потока, который будет выполняться. Если потоков слишком много, то на переключение между ними уходит много времени: из-за постоянных операций выгрузки-загрузки контекста программа выполняется дольше.

Поэтому некоторые современные языки программирования реализуют **легковесные потоки (green threads)**. Такие потоки легче, потому что легче их контекст. Они могут занимать меньший объём stack-памяти и использовать не все регистры. 

За планирование работы лёгких потоков отвечает среда выполнения — рантайм. Благодаря оптимизациям языка переключение между лёгкими потоками происходит быстрее, чем переключение между потоками операционной системы. Операционная система ничего не знает о легковесных потоках, поэтому в каждом языке могут быть свои особенности в реализации таких потоков.

## Многопоточность в Go

В Go реализована CSP-модель. Программа представляет собой множество одновременно работающих подзадач, которые общаются друг с другом с помощью каналов связи. 

В Go модель CSP реализована абстракциями:
- **Горутина (goroutine)** — это легковесный поток, который занимает гораздо меньше памяти, чем поток ОС. Среда выполнения Go может выполнять несколько горутин на одном потоке операционной системы и быстро переключаться с выполнения одной горутины на другую благодаря их малому размеру.
- **Канал (channel)** — это второй ключевой элемент в многопоточности на Go. На каналах построены все механизмы обмена и синхронизации потоков в Go. Одна горутина может записать данные в канал, а другая горутина — прочитать их.

![](./assets/images/goroutine_channel.png)

Планировщик рантайма Go управляет всеми создаваемыми горутинами. Он формирует очереди, каждая из которых привязана к потоку операционной системы. При работе программы очередная горутина берётся из очереди и вместе со своим контекстом отправляется на выполнение в поток ОС. 

Вытесняющий планировщик старается равномерно распределять процессорное время между горутинами. Таким образом, достигается иллюзия параллельности выполнения задач при количестве горутин, многократно превышающем количество доступных системных потоков. 

Принцип работы планировщика рантайма Go представлен на схеме:

![](./assets/images/goruntime.png)

## Проблемы многопоточности

Проблемы с многопоточностью возникают, когда несколько потоков работают с общими данными: обращаются к одной и той же памяти внутри процесса. Самая частая проблема — **состояние гонки (race condition)**.

![](./assets/images/race.png)

Все арифметические и логические действия в коде — это неатомарные операции. Если несколько потоков одновременно запустятся на разных ядрах процессора и начнут записывать данные в одну и ту же область памяти, возникнет конкуренция потоков. Один поток скопирует в свой регистр устаревшую копию данных, другой поток перезапишет данные и поменяет на свою версию и так далее.

![](./assets/images/operation.png)

Но есть способы предотвратить состояние гонки. Вот некоторые из них:
- **Мьютексы** (mutex — от mutual exclusion, что переводится как «взаимное исключение»). Мьютекс — это ресурс, который может быть занят только одним потоком. Для других потоков мьютекс заблокируется — они будут ждать, пока он освободится, чтобы продолжить работу.
- **Атомарные операции**. В современных процессорах запрограммированы команды, которые позволяют производить некоторые арифметические и логические действия атомарно. Используя атомарные операции, можно, к примеру, увеличивать целочисленный счётчик из нескольких потоков одновременно без дополнительных блокировок.
- **Обмен сообщениями**. Даёт потокам возможность обмениваться сообщениями или сигналами. Идея обмена сообщениями в том, чтобы создать очередь, в которую один поток может скопировать данные и из которой другой поток может прочитать свою копию.

В Go используются все три способа. Но самый предпочтительный — обмен сообщениями через каналы. Благодаря им можно написать более простой и надёжный многопоточный код. При передаче данных через канал не требуется дополнительное ограничение доступа к ресурсам, поэтому каналы позволяют минимизировать вероятность ошибки программиста.

Перечислим самые частые ошибки:
- **Взаимная блокировка (deadlock)**. Рассмотрим на примере. Представьте, что в буфете осталась одна ложка и одна вилка. Приходят два покупателя, каждому из которых нужна вилка и ложка. Они одновременно подходят к столовым приборам. Один берёт вилку, другой — ложку. Далее оба будут ждать, когда принесут другой прибор и не смогут начать есть свой заказ. Если в коде используются несколько мьютексов или каналов, то может возникнуть ситуация, когда все потоки ожидают сигналов один от другого и не могут продолжить работу.
- **Живая блокировка (livelock)**. Ещё один пример. Вы договорились созвониться с человеком в определённое время. Каждый раз, когда вы набираете его номер, он звонит вам. Вы отменяете вызов и ждёте какое-то время, но он делает то же самое. Живая блокировка — это cостояние программы, при котором потоки что-то делают, но не выполняют полезной работы. Например, два потока пытаются взять несколько мьютексов. Один берёт А и B, а другой B и A. Если второй мьютекс занят, каждый поток откатывается назад. Оба потока формально не будут заблокированы, но они будут постоянно то блокировать, то разблокировать мьютексы.
- **Голодание (starvation)**. Представьте, что человек едет с вокзала в аэропорт. Вместе с билетом на самолёт он взял priority pass (Priority Pass — международная программа доступа в VIP-залы аэропортов), прошёл вне очереди, но его не пускают — из-за большой сумки в ручной клади. Он ругается, занимает время борт-проводников. Из-за этого никто не может пройти дальше. В коде такая ситуация возникает, когда горутина захватывает мьютекс на большее время, чем ей нужно на самом деле. Из-за этого другим потокам приходится ждать разблокировки мьютекса.

___
Посмотрите на псевдокод и определите, к какой ошибке он может привести, если на двух ядрах процессора одновременно выполняются операции:
- `ПеревестиДеньги(счётВаси, счётПети, 10)`;
- `ПеревестиДеньги(счётПети, счётВаси, 15)`.

```go
func ПеревестиДеньги(счёт1, счёт2, сумма) {
    // функция блокироватьСчёт указывает на начало работы со счётом
    // eсли счёт уже заблокирован, то она будет ожидать его
    // разблокировки (функция разблокироватьСчёт)
    блокироватьСчёт(счёт1)
    счёт1.баланс -= сумма
    
    блокироватьСчёт(счёт2)
    счёт2.баланс += сумма
    
    разблокироватьСчёт(счёт2)
    разблокироватьСчёт(счёт1)
}
```

~~Взаимная блокировка (deadlock). (Могут одновременно заблокироваться счета Васи и Пети, как счёт1, и станет невозможна их блокировка, как счёт2.)~~
___
Соедините инструменты с задачами, которые они решают.

- Мьютексы = передача сообщений между горутинами
- Атомарные операции = изменение глобальной числовой переменной из нескольких потоков
- Каналы = передача сообщений между горутинами

В этом уроке вы рассмотрели основы многопоточного программирования. Ознакомились с наиболее распространёнными ошибками, возникающими при работе потоков, и узнали, как их избежать. Далее погрузимся в особенности многопоточного программирования на Go и рассмотрим, как использовать каналы для передачи данных между горутинами.

## Дополнительные материалы
- [Medium | Race condition и Data Race](https://medium.com/german-gorelkin/race-8936927dba20) — о состоянии гонки.
- [Medium | Deadlocks, Livelocks и Starvation](https://medium.com/german-gorelkin/deadlocks-livelocks-starvation-ccd22d06f3ae) — о взаимной блокировке, живой блокировке и голодании.

# Многопоточность в Go

## Горутины

Горутина — это функция, которая выполняется параллельно с другими функциями. В Go выполнить функцию — это `myFunc()`, a выполнить функцию в новой горутине — это `go myFunc()`. Да, всё так просто :) 

При вызове `go myFunc()` программа не дожидается завершения вызываемой функции, а выполняет идущий далее код.

```go
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 5; i++ {
        time.Sleep(time.Millisecond)        
        fmt.Print(s + ` `)
    }
}

func main() {
    // запустим две горутины с функцией say
    go say(`hello`)
    go say(`world`)
    // обычный вызов функции say
    say(`bye`)
}
```

Программа выведет примерно следующее:
```
world hello bye hello bye world bye hello world world hello bye bye
```

Как видите, горутины выполняются в произвольной последовательности. По умолчанию программа завершает работу, не дожидаясь окончательного выполнения горутин.

Если горутина содержит небольшое количество кода, который больше нигде не нужен, то можно определить её с помощью анонимной функции.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for _, v := range []string{"hello", "world", "bye"} {
        go func(s string) {
            for i := 0; i < 5; i++ {
                fmt.Print(s + ` `)
                time.Sleep(50 * time.Millisecond)
            }
        }(v)
    }
    time.Sleep(time.Second)
}
```
```
bye hello world world bye hello hello world bye bye hello world world bye hello 
```

## Планировщик горутин

- Как работает планировщик горутин?
- Представьте, что вам дали задачу — выкопать канаву. У вас есть команда из десяти человек, но на всех — всего три лопаты. Прежде чем начать работу, вы подумаете, как организовать процесс быстрее и эффективнее. Примерно этим и занимается планировщик Go.

Планировщик горутин — один из элементов рантайма языка. Он отвечает за выполнение горутин в потоках операционной системы. Планировщик равномерно распределяет процессорное время между горутинами, учитывая их сихронизацию и системные вызовы.

Планировщик горутин работает с тремя типами объектов:
- **Логический процессор**. Это ресурс, который объединяет поток операционной системы и очередь горутин. Для каждого логического процессора планировщик достаёт одну горутину из очереди и запускает её в потоке используя контекст логического процессора.
- **Поток операционной системы**. Это сущность операционной системы, в которой происходит процесс выполнения программного кода. Логический процессор закреплён за определённым потоком. Если горутина сделала системный вызов, который переводит поток в режим ожидания результата, например, чтение файла, то планировщик создаёт дополнительный поток операционной системы. На нём будут запускаться следующие горутины из очереди до разблокировки основного потока.
- **Горутина**.

По умолчанию количество логических процессоров берётся из значения переменной среды `GOMAXPROCS` и равно количеству логических ядер компьютера. Например, если у вас восьмиядерный компьютер, планировщик будет распределять горутины по восьми потокам ОС.

![](./assets/images/goroutines.png)

Теперь разберём, как можно влиять на работу горутин. Создатели Go стремятся использовать в планировщике универсальные алгоритмы и настройки. Поэтому для управления планировщиком используют следующие функции пакета `runtime`:
- `GOMAXPROCS(n int) int` — изменяет значение `GOMAXPROCS` и возвращает количество логических процессоров, которое было установлено до вызова функции. Если значение `GOMAXPROCS` больше, чем количество доступных ядер, скорость работы может не измениться. Чтобы узнать количество логических процессоров, укажите в параметре `0`.
- `Gosched()` — приостанавливает текущую горутину, чтобы планировщик переключился на другую. Работа этой горутины возобновится в порядке очерёдности. В версии Go 1.14 появился вытесняющий планировщик: он вытеснит зависшую по процессорному времени горутину. Таким образом, вызывать переключение горутин вручную не нужно.
- `LockOSThread()` — привязывает горутину к текущему потоку операционной системы. Эта функция пригодится при запуске кода на языке C, который требует выполнения в одном и том же потоке.

Стоит упомянуть ещё две функции:
- `NumCPU() int` возвращает количество логических ядер процессора. Можно использовать это значение для ограничения количества горутин.
- `NumGoroutine() int` возвращает количество запущенных горутин. Эта функция будет полезна при наблюдении за работой программы.

Рассмотрим пример, демонстрирующий работу этих функций:
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    fmt.Println("Ядер:", runtime.NumCPU())
    fmt.Println("Логических процессоров:", runtime.GOMAXPROCS(2), 
        "Горутин:", runtime.NumGoroutine())
    go func() {
        time.Sleep(100 * time.Millisecond)
    }()
    fmt.Println("Логических процессоров:", runtime.GOMAXPROCS(0), 
        "Горутин:", runtime.NumGoroutine())
}
```

На 8-ядерном процессоре получим вывод:
```
Ядер: 8
Логических процессоров: 8 Горутин: 1
Логических процессоров: 2 Горутин: 2
```

*Не удивляйтесь, что количество горутин отображается на одну больше, чем было запущено. Дело в том, что при запуске создаётся основная горутина, в которой выполняется код программы.*

## Типы sync.WaitGroup и sync.Once

Если вы запустили несколько горутин и хотите дождаться их завершения в основной функции, используйте тип `sync.WaitGroup`. Он представляет собой переменную со счётчиком горутин, завершения которых необходимо дождаться. Функциональность `WaitGroup` очень проста, состоит всего из трёх методов:
- `(*WaitGroup) Add(delta int)` — изменить значение счётчика на указанную величину;
- `(*WaitGroup) Done()` — уменьшить значение счётчика на единицу;
- `(*WaitGroup) Wait()` — ожидать, когда значение счётчика будет равно нулю.

Вот пример, в котором программа дожидается завершения запущенных горутин:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    const n = 5

    for i := 0; i < n; i++ {
        wg.Add(1) // инкрементируем счётчик, сколько горутин нужно подождать

        go func(i int) {
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("hi %d\n", i)
            // уменьшаем счётчик, когда горутина завершает работу
            wg.Done()
        }(i)
    }

    wg.Wait() // ждём все горутины
    fmt.Println("Всё готово")
}
```

Порядок выполнения горутин предсказать нельзя, но все они завершат свою работу. Вот один из результатов работы программы:
```
hi 0
hi 3
hi 4
hi 2
hi 1
Всё готово
```

___
Рассмотрите код и определите, каким будет результат работы программы. Выберите вариант ответа, не запуская пример. 

Подсказка: суммарное значение параметров во всех `Add()` должно совпадать с количеством вызовов `Done()`.

```go
func main() {
    var wg sync.WaitGroup

    n := 10
    wg.Add(n)
    for i := 0; i < n-1; i++ {
        go func(v int) {
            fmt.Println(v)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```

~~Программа зависнет или завершит работу с ошибкой. (В зависимости от платформы программа зависнет или возникнет ошибка (как правило, `fatal error: all goroutines are asleep - deadlock!`), потому что количество `Done()` меньше `n`.)~~
___

Если требуется выполнить определённое действие только один раз — например, вызвать функцию инициализации при первом обращении к структуре — в Go используется тип `sync.Once`.

Для этого создаётся переменная типа `sync.Once`, и у неё вызывается метод `Do()`, которому передаётся функция. Метод гарантирует, что переданная функция будет выполнена только один раз.

Перейдём к примеру. Напишем код, который вычитывает конфиг (англ. config) и инициализирует структуру при первом обращении к ней:
```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Config struct {
    once sync.Once
    vals map[string]string
}

func (c *Config) Get(k string) (string, bool) {
    c.once.Do(func() {
        // эта инициализация выполнится только один раз
        c.vals = map[string]string{
            "host": "127.0.0.1",
            "port": fmt.Sprintf("%d", rand.Intn(65535)),
        }
    })

    v, ok := c.vals[k]
    return v, ok
}

func main() {
    var cfg Config

    keys := []string{"host", "port", "port", "host", "port"}
    for _, k := range keys {
        go func(k string) {
            // в одной из горутин произойдёт инициализация cfg
            // остальные горутины будут ждать завершения инициализации
            v, ok := cfg.Get(k)
            if !ok {
                return
            }
            fmt.Printf("%s = %s\n", k, v)
        }(k)
    }

    time.Sleep(time.Second)
}
```

Результат:
```
port = 63058
host = 127.0.0.1
port = 63058
port = 63058
host = 127.0.0.1
```

Использование переменной типа `sync.Once` позволяет легко реализовать одноразовое выполнение определённых действий.

## Примитивы синхронизации

Горутины могут использовать одни и те же переменные или ресурсы во время работы. Если операции сводятся только к получению значений, они не нарушают целостность данных. Операции, которые можно выполнять одновременно в разных горутинах, называются **потокобезопасными**. Однако ситуация усложняется, когда горутины могут изменять данные.

Попробуйте запустить код, который заполняет мапу в нескольких горутинах.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    m := make(map[int]int)

    for i := 0; i < 5; i++ {
        go func() {
            for j := 0; j < 1000; j++ {
                if _, ok := m[j]; !ok {
                    m[j] = j
                }
            }
        }()
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```

С большой долей вероятности вы получите ошибку `concurrent map writes` или `concurrent map read and map write`, так как эта операция не потокобезопасна. Для решения этой проблемы нужно исключить другие операции с мапой. В этом помогает синхронизация горутин. Механизмы, которые позволяют горутине на время получить эксклюзивный доступ к данным, называются **примитивами синхронизации**.

Для синхронизации горутин можно использовать три примитива пакета `sync`:
- `sync.Mutex` — примитив, реализующий **мьютекс** в Go. Мьютекс — это механизм, который позволяет выполнить критические участки кода только одной горутиной;
- `sync.RWMutex` — особый вид мьютекса, который позволяет одновременно выполняться либо произвольному количеству операций чтения, либо одной операции записи;
- `sync.Cond` — переменная условия, которая останавливает горутину до получения сигнала.

Рассмотрим каждый элемент подробнее.

### Тип sync.Mutex

Мьютексы применяются, если горутина читает или изменяет данные, которые могут использоваться другим потоком. Для переменной типа `sync.Mutex` можно вызвать два метода:
- `(m *Mutex) Lock()` — блокирует мьютекс. Занять мьютекс может только одна горутина. Если другие горутины вызовут метод `Lock()` для занятого мьютекса, они будут ждать, пока он освободится.
- `(m *Mutex) Unlock()` — разблокирует мьютекс. Горутина должна освободить мьютекс сразу после того, как она закончила работу с общим ресурсом.

*Если вы применяете мьютексы для сихронизации чтения и записи определённых данных, следите за тем, чтобы не было горутин, работающих с этими данными без мьютекса. Иначе вы также будете получать ошибки конкурентного доступа.*

Покажем на примере, как используется `sync.Mutex`. Предположим, что есть два типа горутин. Одни постоянно меняют мапу, а другие читают. Использование мьютекса синхронизирует все обращения к мапе: только одна горутина может читать или менять её.

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func main() {
    var m sync.Mutex
    cache := map[int]int{}

    // горутины, которые изменяют мапу
    for i := 0; i < 10; i++ {
        go func() {
            for {
                m.Lock()
                cache[rand.Intn(5)] = rand.Intn(100)
                m.Unlock()
                time.Sleep(time.Second / 20)
            }
        }()
    }

    // горутины, которые читают мапу
    for i := 0; i < 10; i++ {
        go func() {
            for {
                m.Lock()
                fmt.Printf("%#v\n", cache)
                m.Unlock()
                time.Sleep(time.Second / 100)
            }
        }()
    }

    time.Sleep(1 * time.Second)
}
```

Результат:
```
map[int]int{}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4:60}
map[int]int{2:36, 3:7, 4
...
39081 bytes truncated
```

У такого решения есть недостаток: оно неоптимально с точки зрения производительности. Из мапы данные читаются чаще, чем записываются в неё. Представьте такой случай: данные меняются очень редко, но обращаться к мапе мьютекс всё равно позволяет только одной горутине. Эту проблему решает тип `sync.RWMutex`.

### Тип sync.RWMutex

Этот тип мьютекса позволяет выполнять либо произвольное количество операций чтения, либо одну операцию записи. При этом нельзя выполнять две операции записи или одновременно запись и чтение.

Если горутине нужно изменить данные, то вызывается метод `Lock()`. Если горутина собирается читать данные, то она вызывает метод `RLock()`. Метод `RLock()` не даёт начать запись пока не будут завершены все операции чтения. Для разблокировки следует использовать соответствующие методы — `Unlock()` или `RUnlock()`.

![](./assets/images/RWMutex_methods.png)

Переделаем наш код таким образом, чтобы читать из мапы могли несколько горутин, а записывать в неё — только одна.

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func main() {
    // меняем тип мьютекса
    var m sync.RWMutex
    cache := map[int]int{}

    for i := 0; i < 10; i++ {
        go func() {
            for {
                // здесь остаются блокировки на запись
                m.Lock()
                cache[rand.Intn(5)] = rand.Intn(100)
                m.Unlock()
                time.Sleep(time.Second / 20)
            }
        }()
    }

    for i := 0; i < 10; i++ {
        go func() {
            for {
                // при чтении используем Rlock() и RUnlock()
                m.RLock()
                fmt.Printf("%#v\n", cache)
                m.RUnlock()
                time.Sleep(time.Second / 100)
            }
        }()
    }

    time.Sleep(1 * time.Second)
}
```

Результат:
```
map[int]int{}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
map[int]int{0:85, 1:72, 2:72, 3:75, 4:66}
ma
...
39798 bytes truncated
```

*Обратите внимание! Для снятия блокировки на чтение и запись необходимо использовать разные методы: при `RLock()` используется `RUnlock()`, а при `Lock()` — `Unlock()`.*

___
Рассмотрите код. Каким будет результат его работы? Выберите правильный вариант. 

Подсказка: похожий пример мы рассматривали в начале главы о примитивах синхронизации.

```go
func main() {
    m := make(map[int]int)

    for i := 0; i < 100; i++ {
        go func(v int) {
            m[v] = 1
        }(i)
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```

~~Неопределённое поведение. (Выведет 100 или ошибку `fatal error: concurrent map writes`.)~~
___
Исправьте код из предыдущего задания так, чтобы программа выполнялась корректно и выводила `100`. Подсказка: используйте `sync.Mutex` при изменении мапы.

Решение:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var mu sync.Mutex
    m := make(map[int]int)

    for i := 0; i < 100; i++ {
        go func(v int) {
            mu.Lock()
            m[v] = v
            mu.Unlock()
        }(i)
    }
    time.Sleep(1 * time.Second)
    fmt.Println(len(m))
}
```
___

### Тип sync.Cond

Представьте, что горутина ждёт изменения определённых условий. Чтобы она постоянно не делала проверки, можно «усыпить» её до получения сигнала. Для этого используется **переменная условия** (от англ. condition variable) — примитив синхронизации, который блокирует один или несколько потоков до получения сигнала от другого потока.

Мьютекс блокирует другие горутины, а переменная условия работает по обратному принципу. Одна горутина переменной условия блокирует сама себя, а другим горутинам нужно её «пробудить», то есть освободить.

Переменная типа `sync.Cond` содержит локер-поле `L` типа `sync.Locker`, значениями которого выступают типы `*sync.Mutex` или `*sync.RWMutex`. Значение `L` передаётся в функции `sync.NewCond(l Locker) *Cond`. 

Есть три метода для работы с переменной условия:
- `(*Cond) Wait()` — разблокирует локер `L` и вводит текущую горутину в режим ожидания до получения сигнала. При получении сигнала локер `L` блокируется, и выполняется следующий после `Wait` код. Горутина должна заблокировать `L` перед вызовом `Wait`. Чаще всего встречаются такие варианты использования этого метода:
```go
// вариант 1
c.L.Lock()
c.Wait()
// производим нужные действия
// ...
c.L.Unlock()

// вариант 2
c.L.Lock()
for !condition() {
    c.Wait()
}
// производим нужные действия
// ...
c.L.Unlock()
```
- `(*Cond) Signal()` — разблокирует одну из ожидающих горутин, если такие есть.
- `(*Cond) Broadcast()` — разблокирует все горутины в очереди.

Диалог:
- Почему вызывается `Lock()` перед `Wait()`, а `Unlock()` — после? И обязательны ли эти вызовы?
- Дело в том, что в начале метода `Wait()` происходит разблокировка мьютекса `L` и текущая горутина встаёт в режим ожидания сигнала. Когда приходит сигнал, мьютекс `L` блокируется и `Wait()` завершает работу. Именно поэтому мы должны лочить мьютекс перед вызовом `Wait()` и не забывать освобождать его после.
- Нужен пример.
- `sync.Cond` встречается гораздо реже, чем мьютексы или каналы. `sync.Cond` удобно использовать, когда требуется многократное уведомление о событии неопределённого круга подпиcчиков (горутин).

Разберём пример. При изменении значения переменной нужно, чтобы её обработали несколько разных горутин (воркеров). Для оповещения всех ожидающих горутин будем использовать метод `Broadcast()`. Удобно, что функция, которая отправляет Broadcast-сигнал не знает, сколько запущено воркеров и не должна об этом думать:
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func startWorkers(c *sync.Cond, val *int) {
    workerCount := 3

    for i := 0; i < workerCount; i++ {
        go func(workerId int) {
            c.L.Lock()
            for {
                c.Wait()
                // получили сигнал
                fmt.Printf("val %v processed by worker %v\n", *val, workerId)
            }
        }(i)
    }
}

func main() {
    var m sync.Mutex
    c := sync.NewCond(&m)
    val := 0
    startWorkers(c, &val)
    // ждём, чтобы стартанули все воркеры
    time.Sleep(100 * time.Millisecond)

    for i := 0; i < 4; i++ {
        m.Lock()
        val = i
        fmt.Printf("set val to %v\n", val)
        // отправляем сигнал всем воркерам
        c.Broadcast()
        m.Unlock()
        time.Sleep(time.Millisecond)
    }
}
```

Результат:
```
set val to 0
val 0 processed by worker 1
val 0 processed by worker 2
val 0 processed by worker 0
set val to 1
val 1 processed by worker 0
val 1 processed by worker 1
val 1 processed by worker 2
set val to 2
val 2 processed by worker 2
val 2 processed by worker 0
val 2 processed by worker 1
set val to 3
val 3 processed by worker 1
val 3 processed by worker 2
val 3 processed by worker 0
```

Перечислим ещё раз рассмотренные примитивы синхронизации. 

Если нужно, чтобы часть кода выполнялась только одной горутиной, то следует использовать примитив `sync.Mutex` и управлять его состоянием методами `Lock()` и `Unlock()`. 

Если происходят операции чтения и записи, то можно воспользоваться мьютексом типа `sync.RWMutex`, который позволяет горутинам одновременно читать данные и за счёт этого увеличивает скорость работы. 

Примитив `sync.Cond` даёт горутинам возможность обмениваться сигналами, в том числе отправлять сигнал всем подписчикам. Эта возможность используется редко: в большинстве случаев для обмена сигналами удобнее использовать каналы. О них мы расскажем в следующем уроке.

### Потокобезопасный контейнер для хранения объектов

Представьте ситуацию: в вашей программе постоянно нужно создавать временные объекты для небольшой задачи, после которго они становятся не нужны. 
Например, это могут быть длинные слайсы или буферы с байтами, которые используются для временного хранения данных.

Постоянное создание больших объектов с нуля требует выделения новой памяти, что может сказаться на производительности. 
В таких случаях удобно переиспользовать один объект несколько раз, чтобы избежать новых аллокаций.

Посмотрите на следующий пример. 
В функции foo каждый раз создается новый буфер.

```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    for i := 0; i < 10; i++ {
        foo()
    }
}

func foo() {
    // Создание нового буфера
    var buff bytes.Buffer
    
    buff.WriteString("Foo")
    buff.WriteString("Bar")
    buff.WriteString("Buzz")
    // ...
    
    fmt.Println(buff.String())
}
```

Результат:
```
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
```

### Тип sync.Pool

Одно из решений — переиспользовать один буфер несколько раз после создания. 
Для того, чтобы безопасно использовать один объект в нескольких потоков, в Go существует примитив `sync.Pool`.

Его методы `Put` и `Get` позволяют сохранить объект в пул и получить его обратно.

Посмотрите, как можно изменить предыдущий пример с использованием `sync.Pool`:
```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

var bufferPool = sync.Pool{
    // Функция New сработает, если в пуле нет объекта
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func main() {
    for i := 0; i < 10; i++ {
        foo()
    }
}

func foo() {
    buff := bufferPool.Get().(*bytes.Buffer)
    // В конце отправляем буфер обратно в пул, чтобы переиспользовать 
    defer bufferPool.Put(buff)
    
    // Сбрасываем буфер перед использованием, но выделенная память сохранится
    buff.Reset()
    
    buff.WriteString("Foo")
    buff.WriteString("Bar")
    buff.WriteString("Buzz")
    // ...
    
    fmt.Println(buff.String())
}
```

Результат:
```
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
FooBarBuzz
```

В результате `sync.Pool` дает следующие преимущества:
- Потокобезопасный, можно получать объекты из нескольких потоков,
- Можно настроить функцию-конструктор, которая будет создавать начальные объекты (если контейнер пустой),

К тому же, `sync.Pool` позволяет сохранить несколько объектов. 
Однако пул не гарантирует порядок извлечения этих объектов с помощью метода `Get`.

В следующем сниппете показан пример, в котором в пул помещается и извлекается 10 чисел.

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var intPool sync.Pool
    for i := 0; i < 10; i++ {
        intPool.Put(i)
    }
    
    for i := 0; i < 10; i++ {
        fmt.Print(intPool.Get())
    }
}
```
Результат
```
0987654321
```

___
В следующем сниппете функция `concat` использует буфер для конкатенации (объединения нескольких строк в одну) массива строк. Измените код с использованием `sync.Pool`, чтобы переиспользовать буфер между несколькими конкатенациями.

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

type StringMerger struct {
    buffPool sync.Pool
}

func NewStringMerger() *StringMerger {
    return &StringMerger{}
}

func (s *StringMerger) Merge(strings ...string) string {
    // TODO Исправьте код так, чтобы один буфер мог быть переиспользован для разных конкатенаций.
    
    var buff bytes.Buffer
    for _, s := range strings {
        buff.WriteString(s)
    }
    return buff.String()
}

func main() {
    stringConcat := NewStringMerger()
    
    firstString := stringConcat.Merge("Foo", "Bar", "Buzz")
    secondString := stringConcat.Merge("This is ", "a test line.")
    thirdString := stringConcat.Merge("Hello", ", ", "World!")
    
    _, _ = firstString, secondString
    fmt.Println(thirdString)
}
```

Результат:
```
Hello, World!
```

Подсказка:
В конструкторе `NewStringMerger` настройте функцию создания нового буфера. 
Используйте этот буфер в функции `Merge`.

Решение:
```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

type StringMerger struct {
    buffPool sync.Pool
}

func NewStringMerger() *StringMerger {
    merger := StringMerger{}
    // Настраиваем функцию создания нового буфера
    merger.buffPool = sync.Pool{
        New: func() interface{} {
            return new(bytes.Buffer)
        },
    }
    return &merger
}

func (s *StringMerger) Merge(strings ...string) string {
    buff := s.buffPool.Get().(*bytes.Buffer)
    defer s.buffPool.Put(buff)
    
    buff.Reset()
    for _, s := range strings {
        buff.WriteString(s)
    }
    return buff.String()
}

func main() {
    stringConcat := NewStringMerger()
    
    firstString := stringConcat.Merge("Foo", "Bar", "Buzz")
    secondString := stringConcat.Merge("This is ", "a test line.")
    thirdString := stringConcat.Merge("Hello", ", ", "World!")
    
    _, _ = firstString, secondString
    fmt.Println(thirdString)
}
```
___
В последнем задании вы сможете проверить знания по мьютексам и `WaitGroup` — ключевым элементам при работе с горутинами. Найдите в программе ошибки и исправьте их. Программа должна завершаться без ошибок, а мапа всегда должна содержать 100 элементов.

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var (
        mu sync.Mutex
        wg sync.WaitGroup
    )
    m := make(map[int]int)
    for i := 0; i < 10; i++ {
        go func(v int) {
            wg.Add(1)
            for j := 0; j < 10; j++ {
                mu.Lock()
                defer mu.Unlock()

                k := 10*v + j
                m[k] = k
            }
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println(len(m))
}
```

Результат:
```
0
```

Решение:
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var (
        mu sync.Mutex
        wg sync.WaitGroup
    )
    m := make(map[int]int)
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(v int) {
            for j := 0; j < 10; j++ {
                k := 10*v + j
                mu.Lock()
                m[k] = k
                mu.Unlock()
            }
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println(len(m))
}
```
___

Это был непростой урок, но вы справились! Вы узнали, как создавать горутины и  разграничивать доступ из горутин к общим ресурсам. Работа с горутинами не всегда проста, но она действительно позволяет значительно ускорить выполнение программы и улучшить её производительность. В следующем уроке расскажем о работе с каналами и атомарными операциями.

## Дополнительные материалы
- [GO Scheduler: теперь не кооперативный?](https://habr.com/ru/post/502506/)
- [Как планировщик горутин управляет очередями.](https://calvinfeng.gitbook.io/gonotebook/concurrency/04-01-go-routines)
- [Как планировщик горутин работает с системными вызовами.](https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a)
- [Примитивы синхронизации в Go.](https://medium.com/german-gorelkin/synchronization-primitives-go-8857747d9660)
- [Concurrency Synchronization Techniques Provided in the sync Standard Package.](https://go101.org/article/concurrent-synchronization-more.html)
- [Планирование в Go: Часть I — Планировщик ОС.](https://habr.com/ru/post/478168/)
- [Планирование в Go: Часть II — Планировщик Go.](https://habr.com/ru/post/489862/)

# Каналы