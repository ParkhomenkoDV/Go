// https://golangify.com

// Объявляет пакет, которому принадлежит код
package main

import (
	"fmt" // Делает пакет fmt (формат) доступным для использования
	"math"
	"math/rand"
	"strings"
	"time"
)

func f1() {
	// Выводит текст Hello, playground на экран
	fmt.Println("Hello, playground")
}

/*
func f2() // отсутствует тело функции
{ // ошибка синтаксиса: лишняя точка с запятой или
} // новая строка перед {
*/

func f3() {
	fmt.Println("Hello, Nathan")
	fmt.Println("こんにちは Здравствуйте Hola")
}

func f4() {
	fmt.Print("Мой вес на поверхности Марса равен ")
	fmt.Print(55.0 * 0.3783) // В результате 20.8065
	fmt.Println(" килограммам, а мой возраст равен", 41*365/687, "годам.")
}

func f5() {
	// Выводит: Мой вес на поверхности Марса равен 20.8065 килограммам,
	fmt.Printf("Мой вес на поверхности Марса равен %v килограммам, ", 55.0*0.3783)
	// Выводит: а мой возраст равен 21 годам.
	fmt.Printf("а мой возраст равен %v годам.\n", 41*365/687)
}

func f6() {
	// Выводит: Мой вес на поверхности Земли равен 55 килограммам.
	fmt.Printf("Мой вес на поверхности %v равен %v килограммам.\n", "Земли", 55)
}

func f7() {
	fmt.Printf("%-15v $%4v\n", "SpaceX", 94)
	fmt.Printf("%-15v $%4v\n", "Virgin Galactic", 100)
}

func f8() {
	const lightSpeed = 299792 // км/с
	var distance = 56000000   // км

	fmt.Println(distance/lightSpeed, "секунд") // В результате 186 секунд

	distance = 401000000
	fmt.Println(distance/lightSpeed, "секунд") // В результате 1337 секунд
}

func f9() {
	var distance1 = "1"
	var speed1 = 1

	fmt.Printf("%v %v", distance1, speed1)

	var (
		distance2 = "2"
		speed2    = 2
	)

	fmt.Printf("%v %v", distance2, speed2)

	var distance3, speed3 = "3", 3

	fmt.Printf("%v %v", distance3, speed3)

}

func f10() {
	var weight = 149.0
	fmt.Println(weight)
	weight = weight * 0.3783
	fmt.Println(weight)
	weight *= 0.3783
	fmt.Println(weight)

	var age = 41
	fmt.Println(age)
	age = age + 1 // С днем рождения!
	fmt.Println(age)
	age += 1
	fmt.Println(age)
	age++
	fmt.Println(age)
}

func f11() {
	var num = rand.Intn(10) + 1
	fmt.Println(num)

	num = rand.Intn(10) + 1
	fmt.Println(num)
}

/*
Расстояние между Землей и Марсом в разное время отличается и зависит от того,
где планеты в данный конкретный момент времени находятся на орбите Солнца.
Напишите программу для генерации случайного расстояния в промежутке от 56 000 000 до 401 000 000 км.
*/
func f12() {
	var distance = rand.Intn(401_000_000-56_000_000) + 56_000_000
	fmt.Println(distance)
}

/*
Напишите программу, которая посчитает, как быстро должна передвигаться ракета (км/ч),
чтобы добраться до Марса за 28 дней.
Предположим, что расстояние от Земли до Марса равно 56 000 000 км.
*/
func f13() {
	const hoursPerDay = 24

	var days = 28
	var distance = 56_000_000 // km

	fmt.Println(distance/(days*hoursPerDay), "км/ч")
}

func f14() {
	var (
		walkOutside     = true
		takeTheBluePill = false
	)
	fmt.Printf("%v %v", walkOutside, takeTheBluePill)
}

func f15() {
	fmt.Println("Вы находитесь в темной пещере.")

	var command = "выйти наружу"
	var exit = strings.Contains(command, "наружу")

	fmt.Println("Вы покидаете пещеру:", exit) // Выводит: Вы покидаете пещеру: true
}

/*
== равно
!= не равно
< меньше
> больше
<= меньше или равно
>= больше или равно
*/

func f16() {
	fmt.Println("На знаке снаружи написано 'Несовершеннолетним вход запрещен'.")

	var age = 41
	var adult = age >= 18

	fmt.Printf("В возрасте %v, я совершеннолетний? %v\n", age, adult)
}

func f17() {
	fmt.Println("яблоко" > "банан")
}

func f18() {
	var room = "пещера"

	if room == "пещера" {
		fmt.Println("Вы находитесь в тускло освещенной пещере.")
	} else if room == "вход" {
		fmt.Println("Здесь есть вход в пещеру и путь на восток.")
	} else if room == "гора" {
		fmt.Println("Здесь крутой утес. Тропа ведет к подножью горы.")
	} else {
		fmt.Println("Здесь ничего нет.")
	}
}

/*
else if и else являются опциональными.
Когда рассматривается несколько вариантов, можно повторять else if столько раз, сколько требуется.
*/

/*
Напишем код, что должен определить, будет ли 2100 год високосным.
Правила определения високосного года таковы:
- Любой год, что делится без остатка на четыре, но не делится без остатка на 100;
- Или любой год, что делится без остатка на 400.
*/
func f19() {
	fmt.Println("На дворе 2100 год. Он високосный?")

	var year = 2100
	var leap = year%400 == 0 || (year%4 == 0 && year%100 != 0)

	if leap {
		fmt.Println("Этот год високосный!")
	} else {
		fmt.Println("К сожалению, нет. Этот год не високосный.")
	}
}

func f20() {
	var haveTorch = true
	var litTorch = false

	if !haveTorch || !litTorch {
		fmt.Println("Ничего не видно.") // Вывод: Ничего не видно.
	}
}

func f21() {
	fmt.Println("Здесь вход в пещеру и путь на восток.")
	var command = "зайти внутрь"

	switch command { // Сравнивает case с command
	case "идти на восток":
		fmt.Println("Вы направляетесь к горе.")
	case "зайти в пещеру", "зайти внутрь": // Запятая разделяет список возможных значений
		fmt.Println("Вы находитесь в тускло освещенной пещере.")
	case "прочитать знак":
		fmt.Println("На знаке написано 'Несовершеннолетним вход запрещен'.")
	default:
		fmt.Println("Пока не совсем понятно.")
	}
}

func f22() {
	var room = "озеро"

	switch { // Выражения для каждого случая
	case room == "пещера":
		fmt.Println("Вы находитесь в тускло освещенной пещере.")
	case room == "озеро":
		fmt.Println("Лед кажется достаточно крепким.")
		fallthrough // Переходит на следующий случай бкз сравнения!
	case room == "глубина":
		fmt.Println("Вода такая холодная, что сводит кости.")
	}
}

func f23() {
	var count = 10 // Объявление и инициализация

	for count > 0 { // Условие
		fmt.Println(count)
		time.Sleep(time.Second)
		count-- // Обратный отсчет; в противном случае цикл будет длиться вечно
	}
	fmt.Println("Запуск!")
}

func f24() {
	var degrees = 0

	for {
		fmt.Println(degrees)

		degrees++
		if degrees >= 360 {
			degrees = 0
			if rand.Intn(10) == 0 {
				break
			}
		}
	}
}

/*
Не каждый запуск проходит по плану.
Реализуйте обратный отсчет, где на каждую секунду приходится шанс 1 к 100,
что ввиду определенных обстоятельств запуск прервется, и счетчик остановится.
*/
func f25() {
	var count = 10

	for count > 0 {
		fmt.Println(count)
		time.Sleep(time.Second)
		if rand.Intn(100) == 0 {
			break
		}
		count--

	}
	if count == 0 {
		fmt.Println("Запуск!")
	} else {
		fmt.Println("Запуск отменяется.")
	}
}

func f26() {
	switch time.Now().Weekday() {

	case time.Monday:
		fmt.Println("Сегодня понедельник.")

	case time.Tuesday:
		fmt.Println("Сегодня вторник.")

	case time.Wednesday:
		fmt.Println("Сегодня среда.")

	case time.Thursday:
		fmt.Println("Сегодня четверг.")

	case time.Friday:
		fmt.Println("Сегодня пятница.")

	case time.Saturday:
		fmt.Println("Сегодня суббота.")

	case time.Sunday:
		fmt.Println("Сегодня воскресенье.")
	}
}

func f27() {
	switch time.Now().Weekday() {

	case time.Monday, time.Tuesday, time.Wednesday, time.Thursday, time.Friday:
		fmt.Println("будний день")
	case time.Saturday, time.Sunday:
		fmt.Println("выходные дни")
	}
}

func f28() {
	size := "XXXL"

	switch size {

	case "XXS":
		fmt.Println("очень очень маленький")

	case "XS":
		fmt.Println("очень маленький")

	case "S":
		fmt.Println("маленький")

	case "M":
		fmt.Println("средний")

	case "L":
		fmt.Println("большой")

	case "XL":
		fmt.Println("очень большой")

	case "XXL":
		fmt.Println("очень очень большой")

	default:
		fmt.Println("неизвестно")
	}
}

func f29() {
	switch num := 6; num%2 == 0 {

	case true:
		fmt.Println("even value")

	case false:
		fmt.Println("odd value")
	}
}

func f30() {
	w := "a b c\td\nefg hi"

	for _, e := range w {

		switch e {
		case ' ', '\t', '\n':
			break // заканчивает switch
		default:
			fmt.Printf("%c\n", e)
		}
	}
}

func f31() {

	now := time.Now()

	switch {
	case now.Hour() < 12:
		fmt.Println("AM")

	default:
		fmt.Println("PM")
	}
}

// A -> B -> C -> D -> E

func f32() {

	nextstop := "B"

	fmt.Println("Stops ahead of us:")

	switch nextstop {

	case "A":
		fmt.Println("A")
		fallthrough

	case "B":
		fmt.Println("B")
		fallthrough

	case "C":
		fmt.Println("C")
		fallthrough

	case "D":
		fmt.Println("D")
		fallthrough

	case "E":
		fmt.Println("E")
	}
}

func f33() {

	var data interface{}

	data = 112523652346.23463246345

	switch mytype := data.(type) {

	case string:
		fmt.Println("string")

	case bool:
		fmt.Println("boolean")

	case float64:
		fmt.Println("float64 type")

	case float32:
		fmt.Println("float32 type")

	case int:
		fmt.Println("int")

	default:
		fmt.Printf("%T", mytype)
	}
}

/*
В Go область видимости начинает и заканчивается фигурными скобками {}.
В следующей программе функция main начинает область видимости,
а вместе с циклом for стартует вложенная область.
*/
func f34() {
	var count = 0

	for count < 10 { // Начало области видимости
		var num = rand.Intn(10) + 1
		fmt.Println(num)

		count++
	} // Конец области видимости
}

/*
Переменная count объявляется внутри области видимости функции,
она видима до конца функции main,
в то время как переменная num объявляется внутри области видимости цикла for.
По завершении цикла переменная num выходит из области видимости.

При попытке получить доступ к переменной num после цикла, компилятор Go выведет ошибку.
Однако получить доступ к переменной count по завершении цикла for все еще можно,
ведь ее объявили за пределами цикла, хотя особой причины для этого не было.
Для заключения переменной count в области видимости цикла понадобится использовать другой способ объявления переменных Go.
*/

// краткое объявление переменных в go
func f35() {
	var count1 = 10
	fmt.Println(count1)
	// аналогичная запись
	count2 := 10
	fmt.Println(count2)
}

/*
Поначалу может показаться, что разница невелика,
однако разница в три символа делает сокращенный вариант намного популярнее способа с var.
Кроме того, краткое объявление может использоваться в некоторых местах, где недопустимо ключевое слово var.

В следующей программе показан пример цикла for, что совмещает инициализацию, условие и последующий оператор,
что уменьшает значение count.
При использовании данной формы цикла for очень важен порядок: инициализация, условие, операция.
*/

func f36() {
	var count = 0

	for count = 10; count > 0; count-- {
		fmt.Println(count)
	}

	fmt.Println(count) // count остается в области видимости
}

/*
Не используя краткое объявление, переменную count нужно было бы объявить за пределами цикла,
следовательно, переменная в таком случае после завершения цикла остается в области видимости.

В следующей программе при задействовании краткого объявления,
переменная count объявляется и инициализируется как часть цикла for,
по завершении цикла выходит из области видимости.
Если бы к переменной count доступ был получен за пределами цикла,
тогда компилятор Go выдал бы ошибку undefined: count.
*/

func f37() {
	for count := 10; count > 0; count-- {
		fmt.Println(count)
	} // count больше не в области видимости
}

/*
Краткое объявление дает возможность объявить новую переменную в операторе if.
В следующем коде переменная num может использовать в любом ответвлении оператора if.
*/

func f38() {
	if num := rand.Intn(3); num == 0 {
		fmt.Println("Space Adventures")
	} else if num == 1 {
		fmt.Println("SpaceX")
	} else {
		fmt.Println("Virgin Galactic")
	} //num больше не в области видимости
}

// Краткое объявление может использоваться с оператором switch, как показано в следующей программе:

func f39() {
	switch num := rand.Intn(10); num {
	case 0:
		fmt.Println("Space Adventures")
	case 1:
		fmt.Println("SpaceX")
	case 2:
		fmt.Println("Virgin Galactic")
	default:
		fmt.Println("Random spaceline #", num)
	}
}

//Локальная и глобальная область видимости

/*
Следующий код генерирует и отображает случайную дату — к примеру, дату вылета на Марс.
В нем также представлено несколько областей видимости и показано,
почему особенно важно задуматься об области видимости во время объявления переменной.
*/

var era = "AD" // переменная era доступна через пакет

/*
На заметку:
Краткое объявление недоступно для переменных, объявленных в области видимости пакета,
поэтому переменную era нельзя объявить через era := "AD" в ее текущей позиции.
*/

func f40() {
	year := 2018 // переменные era и year находятся в области видимости

	switch month := rand.Intn(12) + 1; month { // переменные era, year и month в области видимости
	case 2:
		day := rand.Intn(28) + 1 // новый день
		fmt.Println(era, year, month, day)
	case 4, 6, 9, 11:
		day := rand.Intn(30) + 1
		fmt.Println(era, year, month, day)
	default:
		day := rand.Intn(31) + 1
		fmt.Println(era, year, month, day)
	} // month и day за пределами области видимости
} // year за пределами области видимости

/*
Переменная year видна только внутри функции main.
Другие функции видят era, но не year.
Область видимости функции уже, чем область видимости пакета.
Она начинается c ключевого слова func и заканчивается закрывающей скобкой.
*/

/*
Переменная month доступна внутри оператора switch,
но как только оператор switch заканчивается, month выводится из области видимости.
Область видимости начинается с ключевого слова switch и заканчивается закрывающей скобкой switch.
*/

/*
У каждого case есть собственная область видимости и три независимые переменные day.
Как только каждый случай заканчивается, объявленная внутри case переменная day выходит за пределы области видимости.
Это единственная ситуация, когда для обозначения области видимости не используются скобки.
*/

/*
Код примера не идеален.
Узкая область видимости переменных month и day приводит к дубликату кода (Println, Println, Println).
Когда код дублируется, кто-то может пересмотреть код в одной области,
но не в другой (при решений не выводить era, но забыв изменить один case).
Иногда дублированный код имеет смысл,
однако чаше всего он рассматривается как код с запашком и указывается на возможные проблемы в программе.
*/

/*
Для удаления дубликатов и упрощения кода переменные нужно было объявлять в более широкой области видимости функции, делая их доступными после оператора switch для дальнейшей работы.
*/

/*
Время рефакторинга!
Рефакторинг предполагает модификацию кода без изменения его поведения.
Следующая программа по-прежнему выводит случайную дату.
*/

func f41() {
	year := 2018
	month := rand.Intn(12) + 1
	daysInMonth := 31

	switch month {
	case 2:
		daysInMonth = 28
	case 4, 6, 9, 11:
		daysInMonth = 30
	}

	day := rand.Intn(daysInMonth) + 1
	fmt.Println(era, year, month, day)

}

/*
- Открывающая фигурная скобка { вводит новую область видимости, что оканчивается закрывающей скобкой };
- Ключевые слова case и default также вводят новую область видимости, хотя фигурные скобки здесь уже не используются;
- Место объявления переменной определяется тем, в какой она области видимости;
- Переменные, объявленные на той же строке, что и ключевые слова for, if или switch находятся в области видимости до окончания данного оператора;
- Иногда широкая область видимости лучше, а иногда — узкая, все зависит от ситуации.
*/

/*
Измените следующую программу для обработки високосных годов. Код должен:

- Генерировать случайный год вместо постоянного использования 2018;
- Для февраля присвойте daysInMonth на 29 для високосных годов, и 28 для всех остальных. Можете использовать оператор if вместо блока case;
- Используйте цикл for для генерации и отображения 10 случайных дат.
*/

func f42() {
	for count := 0; count < 10; count++ {
		year := 2018 + rand.Intn(10)
		leap := year%400 == 0 || (year%4 == 0 && year%100 != 0)
		month := rand.Intn(12) + 1

		daysInMonth := 31
		switch month {
		case 2:
			daysInMonth = 28
			if leap {
				daysInMonth = 29
			}
		case 4, 6, 9, 11:
			daysInMonth = 30
		}

		day := rand.Intn(daysInMonth) + 1
		fmt.Println(era, year, month, day)
	}
}

//Создание программы для покупки билетов в Golang

/*
Пришло время проверить свои силы. Напишем в Go Playground программу для покупки билетов для путешествия на Марс. В коде используем переменные, константы, switch, if и for.
Для отображения, выравнивания текста и генерации случайных чисел будут задействованы пакеты fmt и math/rand.
*/

/*
Создание программы для покупки билетов в Golang
Примеры кода программ на Golang
Пришло время проверить свои силы. Напишем в Go Playground программу для покупки билетов для путешествия на Марс. В коде используем переменные, константы, switch, if и for. Для отображения, выравнивания текста и генерации случайных чисел будут задействованы пакеты fmt и math/rand.

При планировании поездки на Марс будет удобно собрать расценки различных космических станций в одном месте.
Есть множество сайтов для авиалиний, но не для космических.
Для нас это не будет проблемой. При умелом руководстве, Go сможет решить проблемы подобного рода.
*/

/*
В таблице четыре столбца:

- Космическая станция (Spaceline), что предоставляет услуги;
- Продолжительность (Duration) в днях поездки на Марс в один конец;
- Покрывает ли цена поездку туда и обратно (Trip type);
- Цена (Price) в миллионах долларов.
*/

/*
Для каждого билета случайным образом выбирается космическая станция: Space Adventures, SpaceX или Virgin Galactic.
*/

/*
Датой отправления на каждом билете значится 13 Октября 2020 года. В этот день Марс будет на расстоянии 62 100 000 км от Земли.

Скорость космического корабля будет выбрана случайным образом из диапазона от 16 до 30 км/ч.
Это определит продолжительность поездки на Марс, а также цену билета.
Более быстрые корабли намного дороже. Цены на билеты варьируются от $36 до $50 миллионов.
Цена для поездки туда-обратно удваивается.
*/

const secondsPerDay = 86400

func f43() {
	distance := 62_100_000
	company := ""
	trip := ""

	fmt.Println("Spaceline        Days Trip type  Price")
	fmt.Println("======================================")

	for count := 0; count < 10; count++ {
		switch rand.Intn(3) {
		case 0:
			company = "Space Adventures"
		case 1:
			company = "SpaceX"
		case 2:
			company = "Virgin Galactic"
		}

		speed := rand.Intn(15) + 16                  // 16-30 km/s
		duration := distance / speed / secondsPerDay // days
		price := 20.0 + speed                        // millions

		if rand.Intn(2) == 1 {
			trip = "Round-trip"
			price = price * 2
		} else {
			trip = "One-way"
		}

		fmt.Printf("%-16v %4v %-10v $%4v\n", company, duration, trip, price)
	}
}

//Вещественные числа в Golang — float64 и float32

/*
Текст "Go" и число 28487 на компьютере с архитектурой x86 представлены одним и тем же набором нулей и единиц — 0110111101000111.
Тип устанавливает, что данные биты и байты означают.
В первом случае это строка string из двух символов, а во втором случае — 16-битное число integer (2 байта).
Тип string используется для многоязычного текста, а 16-битный integer является одним из числовых типов.

Компьютерное хранилище манипулирует вещественными числами вроде 3.14159, используя IEEE-754 стандарт с плавающей запятой.
Числа с плавающей запятой могут быть как очень крупными, так и чрезвычайно малыми — для сравнения подумайте о галактиках и атомах.
С многогранностью подобного рода языки программирования вроде JavaScript и Lua справляются через исключительное использование чисел с плавающей запятой.
Компьютеры также используют integer для целых чисел, о чем мы поговорим в следующем уроке.
*/

// Объявление переменных с плавающей запятой в Golang

/*
У каждой переменной есть тип.
При объявлении и инициализации переменной с вещественным числом используется тип с плавающей запятой float.
Следующие три строки кода эквивалентны, так как компилятор Go отнесет переменную days к типу float64 даже без дополнительного уточнения:
*/

func f44() {
	days1 := 365.2425 // краткое объявление
	var days2 = 365.2425
	var days3 float64 = 365.2425

	fmt.Printf("%v %v %v", days1, days2, days3)
}

/*
Важно знать, что у переменной days тип float64, излишне уточнять float64. Разработчики и компилятор Go и так поймут тип, просто посмотрев на значение справа.
Если рассматривается число с десятичной точкой, его тип всегда будет float64.
*/

/*
При инициализации переменной с целым числом Go не будет знать, что вам требуется тип с плавающей запятой, пока вы не уточните данный тип с плавающей запятой:
*/

func f45() {
	var answer float64 = 42
	fmt.Print(answer)
}

//Числа одинарной точности float32

/*
В Go есть два типа данных для чисел с плавающей запятой.
По умолчанию присваивается float64, 64-битный тип с плавающей запятой, что использует восемь байтов памяти.
В некоторых языках программирования при описании 64-битного типа с плавающей запятой используется термин двойная точность.

Тип float32 задействует половину используемой float64 памяти, но является менее точным.
Данный типа еще называют одинарной точностью.
Для использования float32 во время объявления переменной нужно уточнить ее тип.
В следующем коде показан пример использования float32:
*/

func f46() {
	var pi64 = math.Pi
	var pi32 float32 = math.Pi

	fmt.Println(pi64) // Выводит: 3.141592653589793
	fmt.Println(pi32) // Выводит: 3.1415927
}

//Нулевое значение в Golang

/*
В Go у каждого типа есть значение по умолчанию, которое называется нулевым значением.
Значение по умолчанию присваивается при объявлении переменной, которая не инициализируется конкретным значением.
*/

func f47() {
	var price float64  // price := 0.0
	fmt.Println(price) // Выводит: 0
}

//Отображение типа чисел с плавающей запятой в Golang

/*
При использовании Print и Println для типов с плавающей запятой по умолчанию выводится столько знаков, сколько возможно.
Если вам это не нужно, используйте Printf с символом для форматирования %f для уточнения количества чисел после запятой.
*/

func f48() {
	third := 1.0 / 3
	fmt.Println(third)           // Выводит: 0.3333333333333333
	fmt.Printf("%v\n", third)    // Выводит: 0.3333333333333333
	fmt.Printf("%f\n", third)    // Выводит: 0.333333
	fmt.Printf("%.3f\n", third)  // Выводит: 0.333
	fmt.Printf("%4.2f\n", third) // Выводит: 0.33
}

/*
Ширина уточняет минимальное число выводимых символов, включая точку вместе с числами до и после нее.
К примеру, ширина числа 0.33 равна четырем.
Если ширина больше количества необходимых символов, Printf заполнит оставшееся место пробелами.
Если ширина не уточняется, Printf использует количество символов, необходимое для отображения значения.

Для заполнения пропуском нулями вместо пробелов требуется добавить в префикс ширины ноль
*/

func f49() {
	third := 1.0 / 3
	fmt.Printf("%05.2f\n", third) // Выводит: 00.33
}

//Точность чисел с плавающей запятой в Go

/*
В математике некоторые рациональные числа не могут быть точно представлены в форме десятичной дроби.
Число 0.33 является лишь приближенным значением дроби 1/3.
Неудивительно, что при проведении операций над приближенными значения результат также является приближенным:
1/3+1/3+1/3=1
0.33+0.33+0.33=0.99

Числа с плавающей запятой также страдают от ошибок округления.
Разница в том, что машины используют бинарное представление (нули и единицы) вместо десятичного (1-9).
В результате компьютеры могут точно передать значение 1/3, но с другими числами могут быть вызваны ошибки округления.
*/

func f50() {
	third := 1.0 / 3.0
	fmt.Println(third + third + third) // Выводит: 1

	piggyBank := 0.1
	piggyBank += 0.2
	fmt.Println(piggyBank) // Выводит: 0.30000000000000004
}

/*
Как видно в примере, числа с плавающей запятой — это не самый лучший выбор для подсчета денег.
В качестве альтернативы значение суммы можно хранить в центах, что будут представлены типом целых чисел integer.
Данный тип будет рассмотрен в следующем уроке.

С другой стороны, хотя piggyBank потерял цент, это не критично для крупных предприятий или покупок.
Спрятать ошибки округления можно через использование Printf с точностью в два знака.

Для уменьшения ошибок округления рекомендуется проводить умножение перед делением.
Как правило, при осуществлении вычислений в таком порядке результат более точный.
Это показано  в примерах ниже на примере конвертера температуры:
*/

func f51() {
	celsius := 21.0
	fmt.Print((celsius/5.0*9.0)+32, "° F\n")
	fmt.Print((9.0/5.0*celsius)+32, "° F\n")
	// В выводе: 69.80000000000001° F
	fahrenheit := (celsius * 9.0 / 5.0) + 32.0
	fmt.Print(fahrenheit, "° F") // Выводит: 69.8° F
}

//Сравнение чисел с плавающей запятой

/*
В примере из листинга 5 значение piggyBank 0.30000000000000004, а не описанное 0.30.
Имейте это в виду, когда решите сравнить числа с плавающей запятой:
*/

func f52() {
	piggyBank := 0.1
	piggyBank += 0.2
	fmt.Println(piggyBank == 0.3) // Выводит: false
}

/*
Вместо прямого сравнения чисел с плавающей запятой определите абсолютную разницу между двумя числами,
а затем убедитесь, что разница не слишком велика.
Для принятия абсолютного значения float64 в пакете math есть функция Abs:
*/

func f53() {
	piggyBank := 0.1
	piggyBank += 0.2
	fmt.Println(math.Abs(piggyBank-0.3) < 0.000_1) // Выводит: false
}

/*
На заметку: Верхняя граница для ошибки с плавающей запятой для одной операции известна как машинный ноль.
Его значение равно 2-52 для float64 и 2-23 для float32.
К сожалению, ошибки чисел с плавающей запятой можно получить очень быстро.
Добавьте 11 монет ($0.10 каждая) к piggyBank, и ошибки округления превысят 2-52 по сравнению с $1.10.
Это значит, что лучше выбирать допустимое отклонение, отталкиваясь от особенностей рассматриваемого приложения —  в данном случае это 0.0001.
*/

/*
Представьте, что вам нужно накопить денег на подарок другу.
Напишите программу, которая случайным образом размещает монеты пять ($0.05), десять ($0.10) и двадцать пять ($0.25) центов в пустую копилку до тех пор, пока внутри не будет хотя бы двадцать долларов ($20.00).
Пускай после каждого пополнения копилки текущий баланс отображается на экране, отформатированный с нужной шириной и точностью.
*/

func f54() {
	piggyBank := 0.0

	for piggyBank < 20.00 {
		switch rand.Intn(3) {
		case 0:
			piggyBank += 0.05
		case 1:
			piggyBank += 0.10
		case 2:
			piggyBank += 0.25
		}
		fmt.Printf("$%5.2f\n", piggyBank)
	}
}

//Целые числа integer в Golang — выбор верного типа

/*
В Go есть 10 типов данных для целых чисел. В общем и целом их называют integer.
У типов integer нет проблем с точностью, что присуща числам с плавающей запятой float, однако их нельзя использовать для хранения дробей, их диапазон также ограничен.
Тип выбранного целого числа зависит от диапазона значений, которые необходимы для данной конкретной ситуации.
*/

//Объявление переменных integer в Golang

/*
Пять целочисленных типов Go являются подписанными, или знаковыми.
Это значит, что они могут представлять как положительные, так и отрицательные целые числа.
Самым популярным знаковым типом целых чисел является int:
*/

func f55() {
	var year int = 2018
	fmt.Print(year)
}

/*
Другие пять целочисленных типов являются неподписанными, то есть они лишь для положительных чисел.
Для неподписанных целых чисел используется аббревиатура uint
*/

func f56() {
	var month uint = 2
	fmt.Print(month)
}

/*
При использовании назначения типа для целого числа Go всегда выберет тип int.
Следующие три строки кода эквиваленты:
*/

func f57() {
	year1 := 2018
	var year2 = 2018
	var year3 int = 2018
	fmt.Printf("%v %v %v", year1, year2, year3)
}

//Тип целого числа integer для каждого случая Golang

/*
Целые числа, будь они подписанными или нет, отличаются по размеру.
Размер влияет на минимальное и максимальное значение, а также на то, сколько памяти они занимают.
Есть восемь независимых от архитектуры типов суффиксов с количеством необходимых битов.
Показано в следующей таблице:

Тип	    Диапазон                                                Занимаемая память
int8	–128..127	                                            8 бит (1 байт)
uint8	0..255	                                                8 бит (1 байт)
int16	–32_768..32_767	                                        16 бит (2 байта)
uint16	0..65_535	                                            16 бит (2 байта)
int32	–2_147_483_648..2_147_483_647	                        32 бита (4 байта)
uint32	0..4_294_967_295	                                    32 бита (4 байта)
int64	–9_223_372_036_854_775_808..9_223_372_036_854_775_807	64 бита (8 байт)
uint64	0..18_446_744_073_709_551_615                           64 бита (8 байт)

Далее мы рассмотрим, где какие целочисленные типы лучше использовать и когда.
Также будет показано, что произойдет, если программа выйдет за пределы допустимого диапазона.

В таблице выше не указано два целочисленных типа.
Типы int и uint оптимальны для целевого устройства.
Go Playground, Raspberry Pi 2 и более старые мобильные устройства обеспечивают 32-битную среду, int и uint являются 32-битными значениями.
Любой современный компьютер может обеспечить 64-битную среду, где int и uint будут 64-битными значениями.

На заметку: Если работаете на компьютере с 32-битной архитектурой над кодом,
в котором используются числа со значениями более двух миллиардов,
не забудьте использовать типы int64 и uint64 вместо int и uint

Может показаться, что на некоторых устройствах int идентичен int32, а на других — int64, все-таки это три разных типа.
Тип int не является заменой других типов.
*/

//Выбор правильного типа данных для целых чисел в Go

/*
Узнать, к какому типу данных компилятор Go относит определенную переменную, можно через функцию Printf.
У нее есть специальный символ %T, что выводит тип переменной.
*/

func f58() {
	year := 2018
	fmt.Printf("Type %T for %v\n", year, year) // Выводит: Type int for 2018
}

/*
Вместо повторения переменной дважды можно указать Printf,
чтобы тот использовал первый аргумент [1] для второго специального символа для форматирования:
*/

func f59() {
	days := 365.2425
	fmt.Printf("Type %T for %[1]v\n", days) // Выводит: Type float64 for 365.2425
}

/*
Какие типы данных Go присвоит тексту в кавычках, целому числу, вещественному числу и слову true (без кавычек)?
Напишите простой код, где будут объявляться переменные с различными значениями.
Запустите программу и посмотрите, к какому типу Go отнесет каждую переменную.
*/

func f60() {
	a := "text"
	fmt.Printf("Type %T for %[1]v\n", a) // Выводит: Type string for text

	b := 42
	fmt.Printf("Type %T for %[1]v\n", b) // Выводит: Type int for 42

	c := 3.14
	fmt.Printf("Type %T for %[1]v\n", c) // Выводит: Type float64 for 3.14

	d := true
	fmt.Printf("Type %T for %[1]v\n", d) // Выводит: Type bool for true
}

//Шестнадцатеричные значения в Go

/*
Цвета в CSS указываются шестнадцатеричными, а не десятичными значениями.
В шестнадцатеричной системе используется на 6 знаков больше, чем в десятичной.
Первые десять те же самые — от 0 до 9, за ними следуют символы от A до F.
A является эквивалентом 10 в десятичной системе, B — 11 и так далее до F, что соответствует 15.

Десятичная система отлично подходит для организмов с десятью пальцами.
Шестнадцатеричная система лучше подходит компьютерам.
Одно шестнадцатеричное число тратит четыре бита памяти, или полубайта.
Два шестнадцатеричных числа запрашивают ровно восемь битой, то есть один байт,
делая шестнадцатеричную систему удобной для уточнения значений uint8.

В следующей таблице представлены некоторые шестнадцатеричные числа и их эквиваленты в десятичной системе.

Шестнадцатеричное значение	Десятичное значение
A							10
F							15
10							16
FF							255

Для различия между шестнадцатеричными и десятичными значениями Go запрашивает префикс 0х для шестнадцатеричных значений.
Следующие две строки кода эквиваленты:

var red, green, blue uint8 = 0, 141, 213
var red, green, blue uint8 = 0x00, 0x8d, 0xd5

Для отображения чисел в шестнадцатеричной системе можно использовать специальные символы %x или %X с Printf:
*/

func f61() {
	var red1, green1, blue1 uint8 = 0, 141, 213
	var red2, green2, blue2 uint8 = 0x00, 0x8d, 0xd5
	fmt.Printf("%x %x %x", red1, green1, blue1) // Выводит: 0 8d d5
	fmt.Println()
	fmt.Printf("%x %x %x", red2, green2, blue2) // Выводит: 0 8d d5
}

/*
Для вывода цвета, что будет уместен в файле .css, шестнадцатеричным значениям нужны отступы.
С помощью специальных символов %v и %f можно уточнить минимальное количество знаков [2] и нулевой отступ с %02х:
*/

func f62() {
	var red, green, blue uint8 = 0x00, 0x8d, 0xd5
	fmt.Printf("color: #%02x%02x%02x;", red, green, blue) // Выводит: color #008dd5;
}

//Целочисленное переполнение в Go

/*
Целым числам не присущи ошибки округления, характерные для менее точных чисел с плавающей запятой.
Тем не менее, у всех целочисленных типов есть другая проблема: ограниченный диапазон.
При выходе за пределы типового диапазона Go сталкивается с таким явлением, как целочисленное переполнение.

У 8-битного неподписанного целого числа (uint8) диапазон 0-255.
Значения выше 255 возвращаются к 0.
Следующая программа увеличивает подписанные и неподписанные 8-битные целые числа,
что в конечном итоге приводит к целочисленному переполнению.
*/

func f63() {
	var red uint8 = 255
	red++
	fmt.Println(red) // Выводит: 0

	var number int8 = 127
	number += 10
	fmt.Println(number) // Выводит: -128
}

//Биты целочисленных значений

/*
Для того чтобы понять, почему при выходе из диапазона целые числа сбрасываются, рассмотрим биты.
Специальный символ %b покажет биты целочисленного значения.
Как и другие специальные символы %b может задействовать нулевой отступ с минимальной длиной:
*/

func f64() {
	var green uint8 = 3
	fmt.Printf("%08b\n", green) // Выводит: 00000011
	green++
	fmt.Printf("%08b\n", green) // Выводит: 00000100
}

/*
1. Листинг 2 (один из примеров урока) увеличивает значения red и number на 1.
Что произойдет при добавлении более крупного числа к каждой переменной?

2. Рассмотрите иной вариант развития событий.
Что случится при уменьшении значения red, когда то равно 0 или уменьшения number, когда то равно -128?

3. Целочисленное переполнение также касается 16, 32 и 64-битных целых чисел.
Что произойдет при объявлении uint16, присвоенного к максимальному значению 65535, а затем уменьшенному на 1?
*/

func f65() {
	// добавление числа больше, чем 1
	var red uint8 = 255
	red += 2
	fmt.Println(red) // Выводит: 1

	var number int8 = 127
	number += 3
	fmt.Println(number)
}

func f66() {
	// переполнение с другой стороны
	var red = 0
	red--
	fmt.Println(red) // Выводит: 255

	var number = -128
	number--
	fmt.Println(number)
}

func f67() {
	// переполнения 16-битного неподписанного целого числа
	var green uint16 = 65535
	green++
	fmt.Println(green) // Выводит: 0
}

/*
Пакет math определяет math.MaxUint16 как 65535 и min/max константы для каждого независимого от архитектуры целочисленного типа.
Помните, что int и uint могут быть как 32, так и 64-битными, зависит от компьютера.
*/

//Как избежать переполнения по времени в Go

/*
В операционных системах на основе Unix время представлено в виде количества секунд, начиная с 1 Января 1970 UTC (Coordinated Universal Time).
В 2038 году число секунд с 1 Января 1970 году превысит 2 миллиарда, что является пределом для int32.

К счастью, int64 сможет поддерживать даты, следующие после 2038 года. Это одна из тех ситуаций, когда int32 или int совсем не подойдут.
Только целочисленные типы int64 и uint64 могут хранить числа крупнее двух миллиардов на всех платформах.

Код ниже использует функцию Unix из пакета time. Она принимает два параметра int64, отвечая на количество секунд и наносекунд с 1 Января 1970 года.
Использование подходящего крупного значения (более 12 миллиардов) демонстрирует, что датами после 2038 года можно будет оперировать в Go.
*/

func f68() {
	future := time.Unix(12_622_780_800, 0)
	fmt.Println(future) // Выводит: 2370-01-01 00:00:00 +0000 UTC
}

/*
Напишите программу для копилки, где для подсчета количества центов (не долларов) будут использоваться целые числа.
В копилку случайным образом будут складываться монеты в пять (5¢), десять (10¢) и двадцать пять (25¢) центов до тех пор, пока в копилке не будет 25 долларов ($25).

Пускай программа показывает баланс после каждого добавления монет в копилку.
Баланс должен отображаться в долларах. К примеру, $1.05.

При необходимости найти остаток от деления двух чисел используйте оператор модуля %.
*/

func f69() {
	piggyBank := 0

	for piggyBank < 2000 {
		switch rand.Intn(3) {
		case 0:
			piggyBank += 5
		case 1:
			piggyBank += 10
		case 2:
			piggyBank += 25
		}

		dollars := piggyBank / 100
		cents := piggyBank % 100
		fmt.Printf("$%d.%02d\n", dollars, cents)
	}
}

func f() {
	var s string = "123"
	var r rune = 123
	fmt.Printf("%v", s)
	fmt.Printf("%v", r)
}

// main является функцией, с которой все начинается
func main() {
	f()
}
